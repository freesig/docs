{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"coreconcepts/","text":"Coreconcepts \u00b6","title":"Coreconcepts"},{"location":"coreconcepts/#coreconcepts","text":"","title":"Coreconcepts"},{"location":"coreconcepts/hello_gui/","text":"Hello GUI \u00b6 Welcome to the first GUI tutorial. So far we have interacted with our zome using curl or hc test , but that's not as nice as having a GUI. Today you will learn how to interact with a Holochain app using a super simple web page. HTML page \u00b6 You will need somewhere for all your GUI code to live. This will be a different piece of software to your Holochain zome code. So choose somewhere outside your Holochain application. Create a folder for our GUI to live in: cd holochain/coreconcepts mkdir gui cd gui Create a new file called index.html in your favourite editor. It should live at gui/index.html . Start by adding a simple HTML template to index.html . Add this modern template: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello GUI </ title > < meta name = \"description\" content = \"GUI for a Holochain app\" > </ head > < body > </ body > </ html > Inside the <body> tag add a button: < button type = \"button\" > Say Hello </ button > To make things a bit nicer on the eyes you can add the water.css stylesheet. Add this water.css link inside the <head> tag: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" > Run a simple server \u00b6 Your index.html should now look like: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello Gui </ title > < meta name = \"description\" content = \"Gui for a Holochain app\" > < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" > </ head > < body > < button type = \"button\" > Say Hello </ button > </ body > </ html > Enter the nix-shell to make sure you have all the dependencies available: nix-shell https://holochain.love Once that is all up and running, you can fire up a simple server: python -m SimpleHTTPServer And go have a look in your browser at http://0.0.0.0:8000/ . You will see something like this: hc-web-client \u00b6 Time to communicate with the app that you built in the previous tutorials. To make this easy you can use the hc-web-client . It's Holochain's JavaScript library that helps you easily setup a WebSocket connection to your app. Why WebSocket instead of HTTP? \u00b6 Having a WebSocket connection open allows your app to send messages to your GUI. While we are not doing that today, it's good to get familiar with this process. To make this process easy we have precompiled a version of the hc-web-client for you. Download it here , then unzip it and stick it in your GUI directory so that the files lives here: gui/hc-web-client/hc-web-client-0.5.1.browser.min.js gui/hc-web-client/hc-web-client-0.5.1.browser.min.js.map Once that's done you can easily link to the compiled js file by adding this script tag inside your body tag: < script type = \"text/javascript\" src = \"hc-web-client/hc-web-client-0.5.1.browser.min.js\" ></ script > Call the zome function \u00b6 Now that you have linked the hc-web-client.js library you can make a simple zome call with some vanilla JavaScript. Add this function inside your <body> tag: < script type = \"text/javascript\" > Make a WebSocket connection to Holochain on port 3401: var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); Add a hello() JavaScript function so you can call it from your HTML: function hello () { Wait for Holochain to connect and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the hello_holo zome function in the hello zome running on the test-instance instance: callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }) Log the result in the browser's console: . then (( result ) => console . log ( result )) }) } Close the script tag: < /script> This hello function will connect to your app through WebSocket on port 3401 , call the hello zome function, and print the result to your browser's console. Let's make your button call this function by adding an onclick event handler. Add this button inside the <body> tag: < button onclick = \"hello()\" type = \"button\" > Say Hello </ button > Run your app \u00b6 To make a call from the GUI, your Holochain app must be running. So open up a new terminal window, navigate to the app you built in the previous tutorials, and enter the nix-shell: cd holochain/core_concepts/hello nix-shell https://holochain.love Now run your app: hc package hc run -p 3401 Make a zome call \u00b6 Your index.html should look like this: <! doctype html > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello Gui < /title> < meta name = \"description\" content = \"Gui for a Holochain app\" > < meta name = \"author\" content = \"Holochain\" > < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" > < /head> < body > < button onclick = \"hello()\" type = \"button\" > Say Hello < /button> < div >< span > Response :< /span><span id=\"output\"></span></div> < script type = \"text/javascript\" src = \"hc-web-client/hc-web-client-0.5.1.browser.min.js\" >< /script> < script type = \"text/javascript\" > // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } < /script> < /body> < /html> In your other terminal window (the one with the GUI code) run the SimpleHTTPServer again: python -m SimpleHTTPServer Open up your browser and head to 0.0.0.0:8000 . The page will look the same but open you your developer console and click the \"Say Hello\" button. You should see something like this: I'm using Firefox so this might look a little different depending on your browser Woohoo! You have made a call to your Holochain app using a GUI. Render the output \u00b6 It would be nicer if we didn't need to use the developer console to see the result of the hello_holo call. So let's add a place on the page to show it. Add the following HTML inside your <body> tag: < div > Response: < span id = \"output\" ></ span ></ div > The id=\"output\" is what we will use to update this element from a JavaScript function. Add the following lines below you hello function. Add an update_span function that takes the result: function update_span ( result ) { Get the element that you'll be inserting the output into: var span = document . getElementById ( 'output' ); Parse the zome function result as JSON: var output = JSON . parse ( result ); Set the contents of the element to the zome function result: span . textContent = \" \" + output . Ok ; } Finally, update the hello function to call your new update_span function instead of console.log() . Test the output works \u00b6 Head over to 0.0.0.0:8000 in your web browser (you might need to refresh) and you should see this: Now press the Say Hello button and you get your response: Well done! You have a working GUI that can talk to your Holochain app.","title":"Hello GUI"},{"location":"coreconcepts/hello_gui/#hello-gui","text":"Welcome to the first GUI tutorial. So far we have interacted with our zome using curl or hc test , but that's not as nice as having a GUI. Today you will learn how to interact with a Holochain app using a super simple web page.","title":"Hello GUI"},{"location":"coreconcepts/hello_gui/#html-page","text":"You will need somewhere for all your GUI code to live. This will be a different piece of software to your Holochain zome code. So choose somewhere outside your Holochain application. Create a folder for our GUI to live in: cd holochain/coreconcepts mkdir gui cd gui Create a new file called index.html in your favourite editor. It should live at gui/index.html . Start by adding a simple HTML template to index.html . Add this modern template: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello GUI </ title > < meta name = \"description\" content = \"GUI for a Holochain app\" > </ head > < body > </ body > </ html > Inside the <body> tag add a button: < button type = \"button\" > Say Hello </ button > To make things a bit nicer on the eyes you can add the water.css stylesheet. Add this water.css link inside the <head> tag: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" >","title":"HTML page"},{"location":"coreconcepts/hello_gui/#run-a-simple-server","text":"Your index.html should now look like: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello Gui </ title > < meta name = \"description\" content = \"Gui for a Holochain app\" > < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" > </ head > < body > < button type = \"button\" > Say Hello </ button > </ body > </ html > Enter the nix-shell to make sure you have all the dependencies available: nix-shell https://holochain.love Once that is all up and running, you can fire up a simple server: python -m SimpleHTTPServer And go have a look in your browser at http://0.0.0.0:8000/ . You will see something like this:","title":"Run a simple server"},{"location":"coreconcepts/hello_gui/#hc-web-client","text":"Time to communicate with the app that you built in the previous tutorials. To make this easy you can use the hc-web-client . It's Holochain's JavaScript library that helps you easily setup a WebSocket connection to your app.","title":"hc-web-client"},{"location":"coreconcepts/hello_gui/#why-websocket-instead-of-http","text":"Having a WebSocket connection open allows your app to send messages to your GUI. While we are not doing that today, it's good to get familiar with this process. To make this process easy we have precompiled a version of the hc-web-client for you. Download it here , then unzip it and stick it in your GUI directory so that the files lives here: gui/hc-web-client/hc-web-client-0.5.1.browser.min.js gui/hc-web-client/hc-web-client-0.5.1.browser.min.js.map Once that's done you can easily link to the compiled js file by adding this script tag inside your body tag: < script type = \"text/javascript\" src = \"hc-web-client/hc-web-client-0.5.1.browser.min.js\" ></ script >","title":"Why WebSocket instead of HTTP?"},{"location":"coreconcepts/hello_gui/#call-the-zome-function","text":"Now that you have linked the hc-web-client.js library you can make a simple zome call with some vanilla JavaScript. Add this function inside your <body> tag: < script type = \"text/javascript\" > Make a WebSocket connection to Holochain on port 3401: var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); Add a hello() JavaScript function so you can call it from your HTML: function hello () { Wait for Holochain to connect and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the hello_holo zome function in the hello zome running on the test-instance instance: callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }) Log the result in the browser's console: . then (( result ) => console . log ( result )) }) } Close the script tag: < /script> This hello function will connect to your app through WebSocket on port 3401 , call the hello zome function, and print the result to your browser's console. Let's make your button call this function by adding an onclick event handler. Add this button inside the <body> tag: < button onclick = \"hello()\" type = \"button\" > Say Hello </ button >","title":"Call the zome function"},{"location":"coreconcepts/hello_gui/#run-your-app","text":"To make a call from the GUI, your Holochain app must be running. So open up a new terminal window, navigate to the app you built in the previous tutorials, and enter the nix-shell: cd holochain/core_concepts/hello nix-shell https://holochain.love Now run your app: hc package hc run -p 3401","title":"Run your app"},{"location":"coreconcepts/hello_gui/#make-a-zome-call","text":"Your index.html should look like this: <! doctype html > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Hello Gui < /title> < meta name = \"description\" content = \"Gui for a Holochain app\" > < meta name = \"author\" content = \"Holochain\" > < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css\" > < /head> < body > < button onclick = \"hello()\" type = \"button\" > Say Hello < /button> < div >< span > Response :< /span><span id=\"output\"></span></div> < script type = \"text/javascript\" src = \"hc-web-client/hc-web-client-0.5.1.browser.min.js\" >< /script> < script type = \"text/javascript\" > // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } < /script> < /body> < /html> In your other terminal window (the one with the GUI code) run the SimpleHTTPServer again: python -m SimpleHTTPServer Open up your browser and head to 0.0.0.0:8000 . The page will look the same but open you your developer console and click the \"Say Hello\" button. You should see something like this: I'm using Firefox so this might look a little different depending on your browser Woohoo! You have made a call to your Holochain app using a GUI.","title":"Make a zome call"},{"location":"coreconcepts/hello_gui/#render-the-output","text":"It would be nicer if we didn't need to use the developer console to see the result of the hello_holo call. So let's add a place on the page to show it. Add the following HTML inside your <body> tag: < div > Response: < span id = \"output\" ></ span ></ div > The id=\"output\" is what we will use to update this element from a JavaScript function. Add the following lines below you hello function. Add an update_span function that takes the result: function update_span ( result ) { Get the element that you'll be inserting the output into: var span = document . getElementById ( 'output' ); Parse the zome function result as JSON: var output = JSON . parse ( result ); Set the contents of the element to the zome function result: span . textContent = \" \" + output . Ok ; } Finally, update the hello function to call your new update_span function instead of console.log() .","title":"Render the output"},{"location":"coreconcepts/hello_gui/#test-the-output-works","text":"Head over to 0.0.0.0:8000 in your web browser (you might need to refresh) and you should see this: Now press the Say Hello button and you get your response: Well done! You have a working GUI that can talk to your Holochain app.","title":"Test the output works"},{"location":"coreconcepts/hello_holo/","text":"Hello Holo Tutorial \u00b6 Let's begin with the classic Hello World Holo tutorial! You will see it's super easy to create a distributed application with Holochain. Setup \u00b6 Complete the installation guide . This will give you an app development environment including the Holochain developer tool hc . Open up a terminal (command prompt in Windows). Enter the development environment. macOS/Linux (you'll remember this command from the installation tutorial): nix-shell https://holochain.love Windows (do this in the place where you installed Holochain): vagrant up vagrant ssh nix-shell https://holochain.love Initializing your new app \u00b6 Pick a new home for all your future Holochain applications to live. Something like home_directory/holochain/ . Then create a coreconcepts folder for this tutorial series: cd ~ mkdir holochain cd holochain mkdir coreconcepts cd coreconcepts Time to put the holochain command line tool ( hc ) to work and make your app. Initialize a new app and enter the app directory: Run in nix-shell hc init cc_tuts cd cc_tuts Compile \u00b6 It's an always good to frequently compile your app. That way you catch any mistakes early on. Give it a go by asking hc to package your app: Run in nix-shell hc package Packaging your app means you are compiling the code into a DNA file and getting it ready to be run. You should see a successful compilation like this: Created DNA package file at \"/Users/username/holochain/testing_tuts/hello_holo/dist/hello_holo.dna.json\" DNA hash: QmY 7 rhg 4 sf 6 xqQMRL 1 u 1 CnXVgmamTfxC 59 c 9 RaoFqM 2 eRs Generate a zome \u00b6 Your app doesn't really do too much right now because it needs a zome . A zome is Holochain's way of organizing code into nice units that perform a certain task (like saying hello). Generate a zome called hello inside the zome's folder: Run in nix-shell hc generate zomes/hello rust-proc Compile \u00b6 Run in nix-shell hc package Zomes can take a little while to compile the first time. Compiling will be much faster the next time you do it. Feel free to move on with the tutorial while your app compiles. If all went well you should see: > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Compiling hello v0.1.0 ( /Users/username/holochain/core_concepts/hello_hollo/zomes/hello/code ) Finished release [ optimized ] target ( s ) in 11 .95s > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Finished release [ optimized ] target ( s ) in 0 .50s Created DNA package file at \"/Users/username/holochain/core_concepts/hello_hollo/dist/hello_hollo.dna.json\" DNA hash: QmdNyxke1Z9Kunws4WUXHnt4cdKQnPogC7YPpfQx67fo1z Folder layout \u00b6 Look at the folder layout \u00b6 Open the lib.rs file \u00b6 The zome is a Rust project and makes use of macros so you can avoid writing a lot of boilerplate code. The main file you will be editing is hello_hollo/zomes/code/src/lib.rs . Open up the lib.rs file in an editor and let's have a look at the generated code. The following are all the imports. You are telling Rust, \"hey, I need things from all these crates in order to do my job.\" #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; Next are the use statements. They are saying, \"I want to use these specific things from the above crates.\" You only need a few items for this tutorial so go ahead and remove the others: #![feature(proc_macro_hygiene)] - #[macro_use] extern crate hdk; extern crate hdk_proc_macros; extern crate serde; #[macro_use] extern crate serde_derive; extern crate serde_json; - #[macro_use] extern crate holochain_json_derive; use hdk::{ - entry_definition::ValidatingEntryType, error::ZomeApiResult, }; - use hdk::holochain_core_types::{ - entry::Entry, - dna::entry_types::Sharing, - }; - use hdk::holochain_json_api::{ - json::JsonString, - error::JsonError - }; - use hdk::holochain_persistence_api::{ - cas::content::Address - }; use hdk_proc_macros::zome; You should be left with this: use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; There are a few sections of generated code that are not useful for this tutorial. Remove the following piece of code: - #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] - pub struct MyEntry { - content: String, - } The my_zome module is where all your zome code live. #[zome] is a procedural macro that says that the following module defines all the things that Holochain should know about this zome. It saves you writing lots of code. Change it to hello_zome for this tutorial series: #[zome] - mod my_zome { + mod hello_zome { The init function is run when a user starts the app for the first time. Every zome defines this function so it can do some initial setup tasks. In this zome it doesn't do anything. #[init] fn init () { Return success with the empty value () . In Rust () is called the unit type and is similar (though not identical) to a void type in other languages. Ok (()) } This required function is run at application start too, once by the new user and once by the existing peers. It checks that the user is allowed to join the network. In this case it gives everyone a free pass. #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } Remove the following template code: - #[entry_def] - fn my_entry_def() -> ValidatingEntryType { - entry!( - name: \"my_entry\", - description: \"this is a same entry defintion\", - sharing: Sharing::Public, - validation_package: || { - hdk::ValidationPackageDefinition::Entry - }, - validation: | _validation_data: hdk::EntryValidationData<MyEntry>| { - Ok(()) - } - ) - } - - #[zome_fn(\"hc_public\")] - fn create_my_entry(entry: MyEntry) -> ZomeApiResult<Address> { - let entry = Entry::App(\"my_entry\".into(), entry.into()); - let address = hdk::commit_entry(&entry)?; - Ok(address) - } - - #[zome_fn(\"hc_public\")] - fn get_my_entry(address: Address) -> ZomeApiResult<Option<Entry>> { - hdk::get_entry(&address) - } A note about return values \u00b6 You'll often see Rust functions returning some sort of Result value. This is a special Rust type that can either be Ok(some_value) to show that the function succeeded or Err(some_error) to report an error. All required Holochain functions, such as init and validators, are expected return a special result type called ZomeApiResult , which shuttles data back and forth between your app and the conductor. It also automatically converts data to JSON and back, so it makes sense to use it in your public functions too. Add a function to say hello :) \u00b6 Now tell the zome to return Hello Holo from a public function. Locate the validate_agent function: pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } You're going to put your public zome function after it. The hc_public procedural macro will turn the function directly below it into a public function that GUIs, other zomes, and DNAs can call. It takes note of the function's name, the parameters it accepts, and the type of value it returns, so Holochain can call it properly. Add the hc_public macro: #[zome_fn( \"hc_public\" )] The function hello_holo takes no arguments and returns a Holochain result type. We're also telling Holochain that if the result is Ok then it will contain a string. Start the function: fn hello_holo () -> ZomeApiResult < String > { Return an Ok result that contains our greeting. into() is a bit of Rust oddness that just means \"turn this slice into a String \": Ok ( \"Hello Holo\" . into ()) } Compile \u00b6 Check your code #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } } If you do find any errors, remember to fix them before moving on. You can always get help on the forum . Run in nix-shell hc package Talk to your app through HTTP \u00b6 To interact with your application you can run it in HTTP mode. Run in nix-shell hc run -i http You can send a POST message to your app using curl , a little command for making HTTP requests. (It's included in the Holochain dev environment.) You will need to open a new terminal window and enter the nix-shell again: nix-shell https://holochain.love Enter the following request, which will call the hello_holo function and return the result: Run in nix-shell curl -X POST -H \"Content-Type: application/json\" -d '{\"id\": \"0\", \"jsonrpc\": \"2.0\", \"method\": \"call\", \"params\": {\"instance_id\": \"test-instance\", \"zome\": \"hello\", \"function\": \"hello_holo\", \"args\": {} }}' http://127.0.0.1:8888 And you should get back your string from the hello_holo function: { \"jsonrpc\" : \"2.0\" , \"result\" : \"{\\\"Ok\\\":\\\"Hello Holo\\\"}\" , \"id\" : \"0\" } Congratulations --- you have created your first distributed Holochain application!","title":"Hello Holo Tutorial"},{"location":"coreconcepts/hello_holo/#hello-holo-tutorial","text":"Let's begin with the classic Hello World Holo tutorial! You will see it's super easy to create a distributed application with Holochain.","title":"Hello Holo Tutorial"},{"location":"coreconcepts/hello_holo/#setup","text":"Complete the installation guide . This will give you an app development environment including the Holochain developer tool hc . Open up a terminal (command prompt in Windows). Enter the development environment. macOS/Linux (you'll remember this command from the installation tutorial): nix-shell https://holochain.love Windows (do this in the place where you installed Holochain): vagrant up vagrant ssh nix-shell https://holochain.love","title":"Setup"},{"location":"coreconcepts/hello_holo/#initializing-your-new-app","text":"Pick a new home for all your future Holochain applications to live. Something like home_directory/holochain/ . Then create a coreconcepts folder for this tutorial series: cd ~ mkdir holochain cd holochain mkdir coreconcepts cd coreconcepts Time to put the holochain command line tool ( hc ) to work and make your app. Initialize a new app and enter the app directory: Run in nix-shell hc init cc_tuts cd cc_tuts","title":"Initializing your new app"},{"location":"coreconcepts/hello_holo/#compile","text":"It's an always good to frequently compile your app. That way you catch any mistakes early on. Give it a go by asking hc to package your app: Run in nix-shell hc package Packaging your app means you are compiling the code into a DNA file and getting it ready to be run. You should see a successful compilation like this: Created DNA package file at \"/Users/username/holochain/testing_tuts/hello_holo/dist/hello_holo.dna.json\" DNA hash: QmY 7 rhg 4 sf 6 xqQMRL 1 u 1 CnXVgmamTfxC 59 c 9 RaoFqM 2 eRs","title":"Compile"},{"location":"coreconcepts/hello_holo/#generate-a-zome","text":"Your app doesn't really do too much right now because it needs a zome . A zome is Holochain's way of organizing code into nice units that perform a certain task (like saying hello). Generate a zome called hello inside the zome's folder: Run in nix-shell hc generate zomes/hello rust-proc","title":"Generate a zome"},{"location":"coreconcepts/hello_holo/#compile_1","text":"Run in nix-shell hc package Zomes can take a little while to compile the first time. Compiling will be much faster the next time you do it. Feel free to move on with the tutorial while your app compiles. If all went well you should see: > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Compiling hello v0.1.0 ( /Users/username/holochain/core_concepts/hello_hollo/zomes/hello/code ) Finished release [ optimized ] target ( s ) in 11 .95s > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Finished release [ optimized ] target ( s ) in 0 .50s Created DNA package file at \"/Users/username/holochain/core_concepts/hello_hollo/dist/hello_hollo.dna.json\" DNA hash: QmdNyxke1Z9Kunws4WUXHnt4cdKQnPogC7YPpfQx67fo1z","title":"Compile"},{"location":"coreconcepts/hello_holo/#folder-layout","text":"","title":"Folder layout"},{"location":"coreconcepts/hello_holo/#look-at-the-folder-layout","text":"","title":"Look at the folder layout"},{"location":"coreconcepts/hello_holo/#open-the-librs-file","text":"The zome is a Rust project and makes use of macros so you can avoid writing a lot of boilerplate code. The main file you will be editing is hello_hollo/zomes/code/src/lib.rs . Open up the lib.rs file in an editor and let's have a look at the generated code. The following are all the imports. You are telling Rust, \"hey, I need things from all these crates in order to do my job.\" #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; Next are the use statements. They are saying, \"I want to use these specific things from the above crates.\" You only need a few items for this tutorial so go ahead and remove the others: #![feature(proc_macro_hygiene)] - #[macro_use] extern crate hdk; extern crate hdk_proc_macros; extern crate serde; #[macro_use] extern crate serde_derive; extern crate serde_json; - #[macro_use] extern crate holochain_json_derive; use hdk::{ - entry_definition::ValidatingEntryType, error::ZomeApiResult, }; - use hdk::holochain_core_types::{ - entry::Entry, - dna::entry_types::Sharing, - }; - use hdk::holochain_json_api::{ - json::JsonString, - error::JsonError - }; - use hdk::holochain_persistence_api::{ - cas::content::Address - }; use hdk_proc_macros::zome; You should be left with this: use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; There are a few sections of generated code that are not useful for this tutorial. Remove the following piece of code: - #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] - pub struct MyEntry { - content: String, - } The my_zome module is where all your zome code live. #[zome] is a procedural macro that says that the following module defines all the things that Holochain should know about this zome. It saves you writing lots of code. Change it to hello_zome for this tutorial series: #[zome] - mod my_zome { + mod hello_zome { The init function is run when a user starts the app for the first time. Every zome defines this function so it can do some initial setup tasks. In this zome it doesn't do anything. #[init] fn init () { Return success with the empty value () . In Rust () is called the unit type and is similar (though not identical) to a void type in other languages. Ok (()) } This required function is run at application start too, once by the new user and once by the existing peers. It checks that the user is allowed to join the network. In this case it gives everyone a free pass. #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } Remove the following template code: - #[entry_def] - fn my_entry_def() -> ValidatingEntryType { - entry!( - name: \"my_entry\", - description: \"this is a same entry defintion\", - sharing: Sharing::Public, - validation_package: || { - hdk::ValidationPackageDefinition::Entry - }, - validation: | _validation_data: hdk::EntryValidationData<MyEntry>| { - Ok(()) - } - ) - } - - #[zome_fn(\"hc_public\")] - fn create_my_entry(entry: MyEntry) -> ZomeApiResult<Address> { - let entry = Entry::App(\"my_entry\".into(), entry.into()); - let address = hdk::commit_entry(&entry)?; - Ok(address) - } - - #[zome_fn(\"hc_public\")] - fn get_my_entry(address: Address) -> ZomeApiResult<Option<Entry>> { - hdk::get_entry(&address) - }","title":"Open the lib.rs file"},{"location":"coreconcepts/hello_holo/#a-note-about-return-values","text":"You'll often see Rust functions returning some sort of Result value. This is a special Rust type that can either be Ok(some_value) to show that the function succeeded or Err(some_error) to report an error. All required Holochain functions, such as init and validators, are expected return a special result type called ZomeApiResult , which shuttles data back and forth between your app and the conductor. It also automatically converts data to JSON and back, so it makes sense to use it in your public functions too.","title":"A note about return values"},{"location":"coreconcepts/hello_holo/#add-a-function-to-say-hello","text":"Now tell the zome to return Hello Holo from a public function. Locate the validate_agent function: pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } You're going to put your public zome function after it. The hc_public procedural macro will turn the function directly below it into a public function that GUIs, other zomes, and DNAs can call. It takes note of the function's name, the parameters it accepts, and the type of value it returns, so Holochain can call it properly. Add the hc_public macro: #[zome_fn( \"hc_public\" )] The function hello_holo takes no arguments and returns a Holochain result type. We're also telling Holochain that if the result is Ok then it will contain a string. Start the function: fn hello_holo () -> ZomeApiResult < String > { Return an Ok result that contains our greeting. into() is a bit of Rust oddness that just means \"turn this slice into a String \": Ok ( \"Hello Holo\" . into ()) }","title":"Add a function to say hello :)"},{"location":"coreconcepts/hello_holo/#compile_2","text":"Check your code #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } } If you do find any errors, remember to fix them before moving on. You can always get help on the forum . Run in nix-shell hc package","title":"Compile"},{"location":"coreconcepts/hello_holo/#talk-to-your-app-through-http","text":"To interact with your application you can run it in HTTP mode. Run in nix-shell hc run -i http You can send a POST message to your app using curl , a little command for making HTTP requests. (It's included in the Holochain dev environment.) You will need to open a new terminal window and enter the nix-shell again: nix-shell https://holochain.love Enter the following request, which will call the hello_holo function and return the result: Run in nix-shell curl -X POST -H \"Content-Type: application/json\" -d '{\"id\": \"0\", \"jsonrpc\": \"2.0\", \"method\": \"call\", \"params\": {\"instance_id\": \"test-instance\", \"zome\": \"hello\", \"function\": \"hello_holo\", \"args\": {} }}' http://127.0.0.1:8888 And you should get back your string from the hello_holo function: { \"jsonrpc\" : \"2.0\" , \"result\" : \"{\\\"Ok\\\":\\\"Hello Holo\\\"}\" , \"id\" : \"0\" } Congratulations --- you have created your first distributed Holochain application!","title":"Talk to your app through HTTP"},{"location":"coreconcepts/hello_me/","text":"Hello Me \u00b6 Welcome back to another tutorial in the Core Concepts series. Today you will learn how to add an entry type to your zome and start writing entries to your source chain. Remember an entry is a piece of data in your source chain that has been validated. The design of today's app will be: Add a person entry type that stores information about a person. Expose the public function create_person for your UI to create and store a person entry. Expose a public function retrieve_person for your UI to retrieve a person entry. Add the UI components to interact with these functions. This tutorial builds on the previous tutorial so go back and complete that if you haven't already. Test first \u00b6 Let's start by writing a test so it's easy to see we have a working app before writing the UI. Open up your tutorial/test/index.js . This is how we left the testing scenario in the Hello Test tutorial: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here }) Add the new tests below t.deepEqual(result, { Ok: 'Hello Holo' }) . Add a call to the create_person function with a person whose name is Alice: const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); Check that the result of the call is Ok: t . ok ( create_result . Ok ); Add a call to the retrieve_person function with the address from the last call: const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that this call is Ok as well: t . ok ( retrieve_result . Ok ); This is the actual result we want at the end of the test. Check that the entry at the address is indeed Alice : t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Running the test \u00b6 Your test should now look like this: Check your code diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) }) Obviously these tests will fail right now. Can you guess what the first failure will be? Let's have a look. Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Run the test: nix-shell ] hc test Note that this test might actually get stuck because we haven't put in the required functions yet. Press ctrl-c to exit a stuck test. Entry \u00b6 Open up your zomes/hello/code/src/lib.rs file. To add an entry into your source chain you start by telling Holochain what kinds of entry exist. First we'll create a struct to define the shape of the data. In a moment we will add a Person struct, but this is where to put it: // <---- Add the person struct here. #[zome] mod hello_zome { Add the following lines. Allow this struct to be easily converted to and from JSON: #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] Represent a person as a struct: pub struct Person { Represent their name as a String: name : String , } Look for the following lines inside the hello_zome mod. #[zome] mod hello_zome { /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. Add the person_entry_def function, which tells Holochain about the person entry type: #[entry_def] fn person_entry_def () -> ValidatingEntryType { Add the entry! macro that lets you easily create a ValidatingEntryType : entry ! ( Give it the same name as the Person struct, just to be consistent. Entry types are usually in lowercase. Add the name and description of the entry: name : \"person\" , description : \"Person to say hello to\" , Entries of this type are just for this agent's eyes only, so set the entry sharing to private: sharing : Sharing :: Private , Add the validation_package function that says what is needed to validate this entry: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, Add the validation function that validates this entry. It returns that this entry is always Ok as long as it fits the shape of the Person struct: validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Now you can create actual person entries and store them on your source chain. A note on validation: Validation is very important. It is the \"rules of the game\" for your Holochain app. It is meaningful to emphasize that although we are returning Ok(()) that we are still validating that the data type checks as a Person with a name property containing a String . Essentially this rule says the person entry must be in this format. Add some use statements \u00b6 In the above code we have used a few types and macros that are not mentioned anywhere else. So the Rust compiler doesn't know where to find them yet. Add the following use statements: Compile \u00b6 Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Package the app (in the nix-shell) and check that there's no compile errors: nix-shell ] hc package Create a person \u00b6 Now you need a way for you UI to actually create a person entry. Holochain has a concept called hc_public which is a way of telling the runtime make this function available to call from outside this zome. Add the following lines below the previous person_entry_def function. Add a public function that takes a Person and returns a result with an Address : #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { Create an entry from the passed argument: let entry = Entry :: App ( \"person\" . into (), person . into ()); Commit the entry to your local source chain: let address = hdk :: commit_entry ( & entry ) ? ; Return the Ok result with the new person entry's address: Ok ( address ) } Compile \u00b6 Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"person\" . into (), person . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } Check for compile errors again: nix-shell ] hc package Retrieve person \u00b6 Lastly you need a way for your UI to get a person entry back from the source chain. Add the following lines below the create_person function. Add a public retrieve_person function that takes an Address and maybe returns an Entry (because it might not exist): #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { Get the entry from your local storage, asking for it by address: hdk :: get_entry ( & address ) } In Rust the last line is always returned. You do not need to explicitly say return . Test \u00b6 Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"person\" . into (), person . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } Instead of directly compiling, you can run the test you wrote at the start (the test always compiles before it runs): nix-shell ] hc test If everything went smoothly you will see: 1 ..5 # tests 5 # pass 5 # ok UI \u00b6 Now you can move onto the modifying the UI to interact with zome functions you just created. First let's do some housekeeping and move the JavaScript from the previous tutorial into its own file. Go to the GUI project folder that you created in the Hello GUI tutorial: cd holochain/coreconcepts/gui Create a new hello.js file, open it in your favorite editor, and open the index.html alongside it. Move the everything inside the <script> tag into the hello.js : < script type = \"text/javascript\" > <!-- Everything from HERE to --> // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } function update_span ( result ) { var span = document . getElementById ( 'output' ); var output = JSON . parse ( result ); span . textContent = \" \" + output . Ok ; } <!-- HERE --> < /script> Add the src attribute to the <script> tag: < script type = \"text/javascript\" src = \"hello.js\" ></ script > Create person UI widget \u00b6 Let's start with the HTML elements to create a person. Look for the previous 'say hello' elements. < button onclick = \"hello()\" type = \"button\" > Say Hello </ button > < span > Response: </ span >< span id = \"output\" ></ span > <!-- Put the following lines here --> Below them, add a text box so the user can enter their name: < input type = \"text\" id = \"name\" placeholder = \"Enter your name :)\" >< br > Add a button that calls a (yet to be written) JavaScript function called create_person : < button onclick = \"create_person()\" type = \"button\" > Submit Name </ button > Add a span with the id address_output so you can render the result of this call: < div > Address: < span id = \"address_output\" ></ span ></ div > TODO: Add collapsable html code panel. Switch to your hello.js file \u00b6 Let's write the create_person function that will call your zome. Add the create_person function: function create_person () { Get the text box by its ID name and save the current text value into the name variable: var name = document . getElementById ( 'name' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call create_person in your hello zome and pass in the name variable as part of a person structure, then write the result to the console: callZome ( 'test-instance' , 'hello' , 'create_person' )({ person : { name : name } }). then (( result ) => console . log ( result , 'address_output' )) }) } Run the server and open a browser \u00b6 TODO: Add collapsable hello.js code panel. Go ahead and test your first call. Open a new terminal window and enter the nix-shell: nix-shell https://holochain.love Run the server: nix-shell ] python -m SimpleHTTPServer In your other terminal window package and run your zome: nix-shell ] hc package nix-shell ] hc run -p 8080 Now that both your UI server and your Holochain conductor server are running, open up a browser and go to 0.0.0.0:8000 . You should see the HTML elements you created: Open the developer console, enter your name, and press the \"Submit Name\" button. You should something similar to this: The address you see will probably be different, because you probably typed in your own name. Show the new entry's address \u00b6 Now we're going to show the address on the page rather than the developer console. But first, a bit of refactoring. If you make the update_span function more generic, then you can reuse it for each element that shows the output for a zome function. Pass in the element's ID so that the function can be reused: Enter the browser \u00b6 Go back to your browser and refresh the page. This time when you enter your name and press Submit Name , you will see the address show up: Retrieve a person entry and show it in the UI \u00b6 Back in the index.html file now. Add a text box so the user can enter the address that is returned from the create_person function: < input type = \"text\" id = \"address_in\" placeholder = \"Enter the entry address\" >< br > Add a button that calls the (yet to be written) retrieve_person JavaScript function: < button onclick = \"retrieve_person()\" type = \"button\" > Get Entry </ button > Add a span with the ID entry_output to display the person that is returned from the retrieve_person function: < div > Person: < span id = \"entry_output\" ></ span ></ div > Go to your hello.js file \u00b6 Add the retrieve_person function to call the zome function of the same name and show its response: function retrieve_person () { Get the value from the address_in text box: var address = document . getElementById ( 'address_in' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the retrieve_person public zome function, passing in the address. Then pass the result to update_person : callZome ( 'test-instance' , 'hello' , 'retrieve_person' )({ address : address }). then (( result ) => update_person ( result )) }) } Add the update_person function. It is very similar to update_element except that you need to parse the result and then parse the inner array. function update_person ( result ) { var person = document . getElementById ( 'entry_output' ); var output = JSON . parse ( result ); var output = JSON . parse ( output . Ok . App [ 1 ]); person . textContent = \" \" + output . name ; }","title":"Hello Me"},{"location":"coreconcepts/hello_me/#hello-me","text":"Welcome back to another tutorial in the Core Concepts series. Today you will learn how to add an entry type to your zome and start writing entries to your source chain. Remember an entry is a piece of data in your source chain that has been validated. The design of today's app will be: Add a person entry type that stores information about a person. Expose the public function create_person for your UI to create and store a person entry. Expose a public function retrieve_person for your UI to retrieve a person entry. Add the UI components to interact with these functions. This tutorial builds on the previous tutorial so go back and complete that if you haven't already.","title":"Hello Me"},{"location":"coreconcepts/hello_me/#test-first","text":"Let's start by writing a test so it's easy to see we have a working app before writing the UI. Open up your tutorial/test/index.js . This is how we left the testing scenario in the Hello Test tutorial: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here }) Add the new tests below t.deepEqual(result, { Ok: 'Hello Holo' }) . Add a call to the create_person function with a person whose name is Alice: const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); Check that the result of the call is Ok: t . ok ( create_result . Ok ); Add a call to the retrieve_person function with the address from the last call: const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that this call is Ok as well: t . ok ( retrieve_result . Ok ); This is the actual result we want at the end of the test. Check that the entry at the address is indeed Alice : t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }})","title":"Test first"},{"location":"coreconcepts/hello_me/#running-the-test","text":"Your test should now look like this: Check your code diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) }) Obviously these tests will fail right now. Can you guess what the first failure will be? Let's have a look. Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Run the test: nix-shell ] hc test Note that this test might actually get stuck because we haven't put in the required functions yet. Press ctrl-c to exit a stuck test.","title":"Running the test"},{"location":"coreconcepts/hello_me/#entry","text":"Open up your zomes/hello/code/src/lib.rs file. To add an entry into your source chain you start by telling Holochain what kinds of entry exist. First we'll create a struct to define the shape of the data. In a moment we will add a Person struct, but this is where to put it: // <---- Add the person struct here. #[zome] mod hello_zome { Add the following lines. Allow this struct to be easily converted to and from JSON: #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] Represent a person as a struct: pub struct Person { Represent their name as a String: name : String , } Look for the following lines inside the hello_zome mod. #[zome] mod hello_zome { /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. Add the person_entry_def function, which tells Holochain about the person entry type: #[entry_def] fn person_entry_def () -> ValidatingEntryType { Add the entry! macro that lets you easily create a ValidatingEntryType : entry ! ( Give it the same name as the Person struct, just to be consistent. Entry types are usually in lowercase. Add the name and description of the entry: name : \"person\" , description : \"Person to say hello to\" , Entries of this type are just for this agent's eyes only, so set the entry sharing to private: sharing : Sharing :: Private , Add the validation_package function that says what is needed to validate this entry: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, Add the validation function that validates this entry. It returns that this entry is always Ok as long as it fits the shape of the Person struct: validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Now you can create actual person entries and store them on your source chain. A note on validation: Validation is very important. It is the \"rules of the game\" for your Holochain app. It is meaningful to emphasize that although we are returning Ok(()) that we are still validating that the data type checks as a Person with a name property containing a String . Essentially this rule says the person entry must be in this format.","title":"Entry"},{"location":"coreconcepts/hello_me/#add-some-use-statements","text":"In the above code we have used a few types and macros that are not mentioned anywhere else. So the Rust compiler doesn't know where to find them yet. Add the following use statements:","title":"Add some use statements"},{"location":"coreconcepts/hello_me/#compile","text":"Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Package the app (in the nix-shell) and check that there's no compile errors: nix-shell ] hc package","title":"Compile"},{"location":"coreconcepts/hello_me/#create-a-person","text":"Now you need a way for you UI to actually create a person entry. Holochain has a concept called hc_public which is a way of telling the runtime make this function available to call from outside this zome. Add the following lines below the previous person_entry_def function. Add a public function that takes a Person and returns a result with an Address : #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { Create an entry from the passed argument: let entry = Entry :: App ( \"person\" . into (), person . into ()); Commit the entry to your local source chain: let address = hdk :: commit_entry ( & entry ) ? ; Return the Ok result with the new person entry's address: Ok ( address ) }","title":"Create a person"},{"location":"coreconcepts/hello_me/#compile_1","text":"Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"person\" . into (), person . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } Check for compile errors again: nix-shell ] hc package","title":"Compile"},{"location":"coreconcepts/hello_me/#retrieve-person","text":"Lastly you need a way for your UI to get a person entry back from the source chain. Add the following lines below the create_person function. Add a public retrieve_person function that takes an Address and maybe returns an Entry (because it might not exist): #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { Get the entry from your local storage, asking for it by address: hdk :: get_entry ( & address ) } In Rust the last line is always returned. You do not need to explicitly say return .","title":"Retrieve person"},{"location":"coreconcepts/hello_me/#test","text":"Check your code #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"person\" . into (), person . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } Instead of directly compiling, you can run the test you wrote at the start (the test always compiles before it runs): nix-shell ] hc test If everything went smoothly you will see: 1 ..5 # tests 5 # pass 5 # ok","title":"Test"},{"location":"coreconcepts/hello_me/#ui","text":"Now you can move onto the modifying the UI to interact with zome functions you just created. First let's do some housekeeping and move the JavaScript from the previous tutorial into its own file. Go to the GUI project folder that you created in the Hello GUI tutorial: cd holochain/coreconcepts/gui Create a new hello.js file, open it in your favorite editor, and open the index.html alongside it. Move the everything inside the <script> tag into the hello.js : < script type = \"text/javascript\" > <!-- Everything from HERE to --> // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } function update_span ( result ) { var span = document . getElementById ( 'output' ); var output = JSON . parse ( result ); span . textContent = \" \" + output . Ok ; } <!-- HERE --> < /script> Add the src attribute to the <script> tag: < script type = \"text/javascript\" src = \"hello.js\" ></ script >","title":"UI"},{"location":"coreconcepts/hello_me/#create-person-ui-widget","text":"Let's start with the HTML elements to create a person. Look for the previous 'say hello' elements. < button onclick = \"hello()\" type = \"button\" > Say Hello </ button > < span > Response: </ span >< span id = \"output\" ></ span > <!-- Put the following lines here --> Below them, add a text box so the user can enter their name: < input type = \"text\" id = \"name\" placeholder = \"Enter your name :)\" >< br > Add a button that calls a (yet to be written) JavaScript function called create_person : < button onclick = \"create_person()\" type = \"button\" > Submit Name </ button > Add a span with the id address_output so you can render the result of this call: < div > Address: < span id = \"address_output\" ></ span ></ div > TODO: Add collapsable html code panel.","title":"Create person UI widget"},{"location":"coreconcepts/hello_me/#switch-to-your-hellojs-file","text":"Let's write the create_person function that will call your zome. Add the create_person function: function create_person () { Get the text box by its ID name and save the current text value into the name variable: var name = document . getElementById ( 'name' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call create_person in your hello zome and pass in the name variable as part of a person structure, then write the result to the console: callZome ( 'test-instance' , 'hello' , 'create_person' )({ person : { name : name } }). then (( result ) => console . log ( result , 'address_output' )) }) }","title":"Switch to your hello.js file"},{"location":"coreconcepts/hello_me/#run-the-server-and-open-a-browser","text":"TODO: Add collapsable hello.js code panel. Go ahead and test your first call. Open a new terminal window and enter the nix-shell: nix-shell https://holochain.love Run the server: nix-shell ] python -m SimpleHTTPServer In your other terminal window package and run your zome: nix-shell ] hc package nix-shell ] hc run -p 8080 Now that both your UI server and your Holochain conductor server are running, open up a browser and go to 0.0.0.0:8000 . You should see the HTML elements you created: Open the developer console, enter your name, and press the \"Submit Name\" button. You should something similar to this: The address you see will probably be different, because you probably typed in your own name.","title":"Run the server and open a browser"},{"location":"coreconcepts/hello_me/#show-the-new-entrys-address","text":"Now we're going to show the address on the page rather than the developer console. But first, a bit of refactoring. If you make the update_span function more generic, then you can reuse it for each element that shows the output for a zome function. Pass in the element's ID so that the function can be reused:","title":"Show the new entry's address"},{"location":"coreconcepts/hello_me/#enter-the-browser","text":"Go back to your browser and refresh the page. This time when you enter your name and press Submit Name , you will see the address show up:","title":"Enter the browser"},{"location":"coreconcepts/hello_me/#retrieve-a-person-entry-and-show-it-in-the-ui","text":"Back in the index.html file now. Add a text box so the user can enter the address that is returned from the create_person function: < input type = \"text\" id = \"address_in\" placeholder = \"Enter the entry address\" >< br > Add a button that calls the (yet to be written) retrieve_person JavaScript function: < button onclick = \"retrieve_person()\" type = \"button\" > Get Entry </ button > Add a span with the ID entry_output to display the person that is returned from the retrieve_person function: < div > Person: < span id = \"entry_output\" ></ span ></ div >","title":"Retrieve a person entry and show it in the UI"},{"location":"coreconcepts/hello_me/#go-to-your-hellojs-file","text":"Add the retrieve_person function to call the zome function of the same name and show its response: function retrieve_person () { Get the value from the address_in text box: var address = document . getElementById ( 'address_in' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the retrieve_person public zome function, passing in the address. Then pass the result to update_person : callZome ( 'test-instance' , 'hello' , 'retrieve_person' )({ address : address }). then (( result ) => update_person ( result )) }) } Add the update_person function. It is very similar to update_element except that you need to parse the result and then parse the inner array. function update_person ( result ) { var person = document . getElementById ( 'entry_output' ); var output = JSON . parse ( result ); var output = JSON . parse ( output . Ok . App [ 1 ]); person . textContent = \" \" + output . name ; }","title":"Go to your hello.js file"},{"location":"coreconcepts/hello_test/","text":"Hello Test Tutorial \u00b6 Welcome to the Hello Test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous Hello Holo tutorial, so make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used. Understand the tests \u00b6 When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in JavaScript and use the Holochain testing framework Diorama , along with a popular test harness called Tape . You can run them with Node.JS , a runtime that lets you execute JavaScript in the terminal. Open up the cc_tuts/test/index.js in your favourite text editor. Have a look through the code. Imports required to do testing: const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) This is a catch-all error logger that will let you know if a Promise fails and there's no error handler to hear it. Promise s are a way of simplifying complex asynchronous code, and Diorama uses a lot of them. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled DNA. const dnaPath = path . join ( __dirname , \"../dist/cc_tuts.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'cc_tuts' ) Setup a testing scenario. This creates two agents: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that Holochain generated based on the my_entry struct and the zome functions that work with it. We removed them in our Hello Holo tutorial, so let's remove the test. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run () Create a test scenario \u00b6 Tests are organized by creating scenarios. Think of them as a series of actions that the user or group of users take when interacting with your app. For this test you simply want to get the Alice user to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function, passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is okay: t . ok ( result . Ok ); Check that the result matches what you expected: Check your code const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); const dnaPath = path . join ( __dirname , \"../dist/cc_tuts.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'cc_tuts' ) const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); t . ok ( result . Ok ); t . deepEqual ( result , { Ok : 'Hello Holo' }) }) diorama . run () Now in the hello_helo directory, run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output. But if everything went okay, then right at the end you will see: # tests 2 # pass 2 # ok Congratulations; you have tested your first Holochain app. Look at you go!","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_test/#hello-test-tutorial","text":"Welcome to the Hello Test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous Hello Holo tutorial, so make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used.","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_test/#understand-the-tests","text":"When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in JavaScript and use the Holochain testing framework Diorama , along with a popular test harness called Tape . You can run them with Node.JS , a runtime that lets you execute JavaScript in the terminal. Open up the cc_tuts/test/index.js in your favourite text editor. Have a look through the code. Imports required to do testing: const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) This is a catch-all error logger that will let you know if a Promise fails and there's no error handler to hear it. Promise s are a way of simplifying complex asynchronous code, and Diorama uses a lot of them. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled DNA. const dnaPath = path . join ( __dirname , \"../dist/cc_tuts.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'cc_tuts' ) Setup a testing scenario. This creates two agents: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that Holochain generated based on the my_entry struct and the zome functions that work with it. We removed them in our Hello Holo tutorial, so let's remove the test. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run ()","title":"Understand the tests"},{"location":"coreconcepts/hello_test/#create-a-test-scenario","text":"Tests are organized by creating scenarios. Think of them as a series of actions that the user or group of users take when interacting with your app. For this test you simply want to get the Alice user to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function, passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is okay: t . ok ( result . Ok ); Check that the result matches what you expected: Check your code const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); const dnaPath = path . join ( __dirname , \"../dist/cc_tuts.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'cc_tuts' ) const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); t . ok ( result . Ok ); t . deepEqual ( result , { Ok : 'Hello Holo' }) }) diorama . run () Now in the hello_helo directory, run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output. But if everything went okay, then right at the end you will see: # tests 2 # pass 2 # ok Congratulations; you have tested your first Holochain app. Look at you go!","title":"Create a test scenario"},{"location":"coreconcepts/hello_world/","text":"Hello World \u00b6 The goal of this tutorial is to add an entry in Alice's instance and then retrieve that same entry in Bob's instance. Make your entry public \u00b6 So far the only entry you have had has been private. But this isn't that useful if you want your users to be able to share entries on the same network. Open up your zomes/hello/code/src/lib.rs file. Change the entry sharing to Sharing::Public : Add Bob to the test \u00b6 Previously you made a test where Alice made a few zome calls and verified the results. Now, to test that the entries can be shared between agents on the same DNA, you can use Bob in your tests to interact with Alice. Open up your test/index.js file and add/update the following lines: Add bob to the scenario: - diorama.registerScenario(\"Test Hello Holo\", async (s, t, { alice }) => { + diorama.registerScenario(\"Test Hello Holo\", async (s, t, { alice, bob }) => { Make the retrieve_person call with the result from create_person : const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that the result was Ok: t . ok ( bob_retrieve_result . Ok ); Check that the result does indeed match the person entry that Alice created: t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Your test should look like this: Check your code Run the test \u00b6 Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Now run the test and make sure it passes: nix-shell ] hc test 1..7 # tests 7 # pass 7 # ok Conductor \u00b6 Now it would be cool to see this happen for real outside of a test. Up till now you have only used hc run to run a single instance of a node. However, in order to have two separate instances communicate on one machine, we need to run holochain directly and pass it a config file. Note \u00b6 hc and holochain are both conductors that host your apps on your users' machines. hc run is for testing and development, and holochain is for end-users. It can host multiple instances of multiple DNAs for multiple users. Normally Alice and Bob would be running instances of your app in their own conductors on their own machines. But for the purposes of this tutorial, it'll be a lot more convenient to try this on one machine, so you don't have to worry about network setup. Before you can create the config file, you will need to generate some keys for your agents. Use hc keygen in your nix-shell to generate a key for each agent: nix-shell] hc keygen -n This will output something similar to the following: Generating keystore (this will take a few moments)... Succesfully created new agent keystore. Public address: HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz Keystore written to: /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz You can set this file in a conductor config as keystore_file for an agent. Take note of the Public address ; you will need it later. Copy the newly generated keystore to your working folder (replace the path with the one in the Keystore written to: line from the output of the previous command): cp <path_of_generated_keystore> agent1.key Now run hc keygen again but copy the key store to agent2.key: cp <path_of_generated_keystore> agent2.key Config file \u00b6 Create a new file in the root directory of your project called conductor-config.toml . Add an agent with ID test_agent1 and name it Agent 1 : # ----------- Agents ----------- [[agents]] id = \"test_agent1\" name = \"Agent 1\" Use the public address and keystore from hc keygen that you made for agent 1 before here: public_address = \"<public_address_of_agent_1>\" keystore_file = \"./agent1.key\" Add an agent with ID test_agent2 and name it Agent 2 : [[agents]] id = \"test_agent2\" name = \"Agent 2\" Use the public address and keystore from hc keygen that you made for agent 2 before here: public_address = \"<public_address_of_agent_2>\" keystore_file = \"./agent2.key\" Package your DNA and take note of its hash: nix-shell] hc package You will see something similar to this: DNA hash: QmS7wUJj6XZR1SBVk1idGh6bK8gN6RNSFXP2GoC8yCJUzn Add the DNA to your config file with ID hello and the hash you just saw above: # ----------- DNAs ----------- [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<dna_hash>\" Connect agent 1 to the hello DNA to create an instance for Alice: [[instances]] id = \"Alice\" dna = \"hello\" agent = \"test_agent1\" [instances.storage] type = \"memory\" Add the Bob instance with the same hello dna: [[instances]] id = \"Bob\" dna = \"hello\" agent = \"test_agent2\" [instances.storage] type = \"memory\" Setup the WebSocket interface on socket 3041 : [[interfaces]] id = \"websocket_interface\" [interfaces.driver] type = \"websocket\" port = 3401 Add your instances to this interface so you can call their zome functions: [[interfaces.instances]] id = \"Alice\" [[interfaces.instances]] id = \"Bob\" Note \u00b6 Again, in real life Alice and Bob would each have their own conductor, so they wouldn't be listening on the same WebSocket interface. Allow the users to choose their instance \u00b6 Before you can use two agents, you need a way for the UI to specify which instance the user wants to use. You can do this by setting the instance ID in the zome call. You can think of an instance as a running version of a DNA, in the same way that a variable is an instance of a struct. Open the gui/index.html file. Add a text box for your users to set the agent ID: < input type = \"text\" id = \"instance\" placeholder = \"Enter your instance ID\" >< br > Open the gui/index.js and do the following for every callZome call: Run the app and two UIs \u00b6 Now the fun part, where you get to play with what you just wrote. Open up three terminal windows and enter the nix-shell in each one: nix-shell https://holochain.love Terminal one \u00b6 Go to the root folder of your app: nix-shell] cd /path/to/my/app Start by running the conductor. It's a bit different this time; instead of hc run you will use holochain directly: nix-shell] holochain -c conductor-config.toml Terminal two \u00b6 Go to the root folder of your GUI: nix-shell] cd /path/to/my/gui Run a GUI on port 8000 : nix-shell] python -m SimpleHTTPServer 8000 Terminal three \u00b6 Go to the root folder of your GUI: nix-shell] cd /path/to/my/gui Run a GUI on port 8001 : nix-shell] python -m SimpleHTTPServer 8001 Open up the browser \u00b6 Open two tabs. Tab one \u00b6 Go to 0.0.0.0:8000 . Enter Alice into the Enter your instance ID text box. Tab two \u00b6 Go to 0.0.0.0:8001 . Enter Bob into the Enter your instance ID text box. Tab one --- Alice \u00b6 Create a person entry with your name: Tab two --- Bob \u00b6 Copy the address from the Alice tab and retrieve the person entry: Hooray! Alice and Bob are now able to find each other's information on the DHT","title":"Hello World"},{"location":"coreconcepts/hello_world/#hello-world","text":"The goal of this tutorial is to add an entry in Alice's instance and then retrieve that same entry in Bob's instance.","title":"Hello World"},{"location":"coreconcepts/hello_world/#make-your-entry-public","text":"So far the only entry you have had has been private. But this isn't that useful if you want your users to be able to share entries on the same network. Open up your zomes/hello/code/src/lib.rs file. Change the entry sharing to Sharing::Public :","title":"Make your entry public"},{"location":"coreconcepts/hello_world/#add-bob-to-the-test","text":"Previously you made a test where Alice made a few zome calls and verified the results. Now, to test that the entries can be shared between agents on the same DNA, you can use Bob in your tests to interact with Alice. Open up your test/index.js file and add/update the following lines: Add bob to the scenario: - diorama.registerScenario(\"Test Hello Holo\", async (s, t, { alice }) => { + diorama.registerScenario(\"Test Hello Holo\", async (s, t, { alice, bob }) => { Make the retrieve_person call with the result from create_person : const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that the result was Ok: t . ok ( bob_retrieve_result . Ok ); Check that the result does indeed match the person entry that Alice created: t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Your test should look like this: Check your code","title":"Add Bob to the test"},{"location":"coreconcepts/hello_world/#run-the-test","text":"Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Now run the test and make sure it passes: nix-shell ] hc test 1..7 # tests 7 # pass 7 # ok","title":"Run the test"},{"location":"coreconcepts/hello_world/#conductor","text":"Now it would be cool to see this happen for real outside of a test. Up till now you have only used hc run to run a single instance of a node. However, in order to have two separate instances communicate on one machine, we need to run holochain directly and pass it a config file.","title":"Conductor"},{"location":"coreconcepts/hello_world/#note","text":"hc and holochain are both conductors that host your apps on your users' machines. hc run is for testing and development, and holochain is for end-users. It can host multiple instances of multiple DNAs for multiple users. Normally Alice and Bob would be running instances of your app in their own conductors on their own machines. But for the purposes of this tutorial, it'll be a lot more convenient to try this on one machine, so you don't have to worry about network setup. Before you can create the config file, you will need to generate some keys for your agents. Use hc keygen in your nix-shell to generate a key for each agent: nix-shell] hc keygen -n This will output something similar to the following: Generating keystore (this will take a few moments)... Succesfully created new agent keystore. Public address: HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz Keystore written to: /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz You can set this file in a conductor config as keystore_file for an agent. Take note of the Public address ; you will need it later. Copy the newly generated keystore to your working folder (replace the path with the one in the Keystore written to: line from the output of the previous command): cp <path_of_generated_keystore> agent1.key Now run hc keygen again but copy the key store to agent2.key: cp <path_of_generated_keystore> agent2.key","title":"Note"},{"location":"coreconcepts/hello_world/#config-file","text":"Create a new file in the root directory of your project called conductor-config.toml . Add an agent with ID test_agent1 and name it Agent 1 : # ----------- Agents ----------- [[agents]] id = \"test_agent1\" name = \"Agent 1\" Use the public address and keystore from hc keygen that you made for agent 1 before here: public_address = \"<public_address_of_agent_1>\" keystore_file = \"./agent1.key\" Add an agent with ID test_agent2 and name it Agent 2 : [[agents]] id = \"test_agent2\" name = \"Agent 2\" Use the public address and keystore from hc keygen that you made for agent 2 before here: public_address = \"<public_address_of_agent_2>\" keystore_file = \"./agent2.key\" Package your DNA and take note of its hash: nix-shell] hc package You will see something similar to this: DNA hash: QmS7wUJj6XZR1SBVk1idGh6bK8gN6RNSFXP2GoC8yCJUzn Add the DNA to your config file with ID hello and the hash you just saw above: # ----------- DNAs ----------- [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<dna_hash>\" Connect agent 1 to the hello DNA to create an instance for Alice: [[instances]] id = \"Alice\" dna = \"hello\" agent = \"test_agent1\" [instances.storage] type = \"memory\" Add the Bob instance with the same hello dna: [[instances]] id = \"Bob\" dna = \"hello\" agent = \"test_agent2\" [instances.storage] type = \"memory\" Setup the WebSocket interface on socket 3041 : [[interfaces]] id = \"websocket_interface\" [interfaces.driver] type = \"websocket\" port = 3401 Add your instances to this interface so you can call their zome functions: [[interfaces.instances]] id = \"Alice\" [[interfaces.instances]] id = \"Bob\"","title":"Config file"},{"location":"coreconcepts/hello_world/#note_1","text":"Again, in real life Alice and Bob would each have their own conductor, so they wouldn't be listening on the same WebSocket interface.","title":"Note"},{"location":"coreconcepts/hello_world/#allow-the-users-to-choose-their-instance","text":"Before you can use two agents, you need a way for the UI to specify which instance the user wants to use. You can do this by setting the instance ID in the zome call. You can think of an instance as a running version of a DNA, in the same way that a variable is an instance of a struct. Open the gui/index.html file. Add a text box for your users to set the agent ID: < input type = \"text\" id = \"instance\" placeholder = \"Enter your instance ID\" >< br > Open the gui/index.js and do the following for every callZome call:","title":"Allow the users to choose their instance"},{"location":"coreconcepts/hello_world/#run-the-app-and-two-uis","text":"Now the fun part, where you get to play with what you just wrote. Open up three terminal windows and enter the nix-shell in each one: nix-shell https://holochain.love","title":"Run the app and two UIs"},{"location":"coreconcepts/hello_world/#terminal-one","text":"Go to the root folder of your app: nix-shell] cd /path/to/my/app Start by running the conductor. It's a bit different this time; instead of hc run you will use holochain directly: nix-shell] holochain -c conductor-config.toml","title":"Terminal one"},{"location":"coreconcepts/hello_world/#terminal-two","text":"Go to the root folder of your GUI: nix-shell] cd /path/to/my/gui Run a GUI on port 8000 : nix-shell] python -m SimpleHTTPServer 8000","title":"Terminal two"},{"location":"coreconcepts/hello_world/#terminal-three","text":"Go to the root folder of your GUI: nix-shell] cd /path/to/my/gui Run a GUI on port 8001 : nix-shell] python -m SimpleHTTPServer 8001","title":"Terminal three"},{"location":"coreconcepts/hello_world/#open-up-the-browser","text":"Open two tabs.","title":"Open up the browser"},{"location":"coreconcepts/hello_world/#tab-one","text":"Go to 0.0.0.0:8000 . Enter Alice into the Enter your instance ID text box.","title":"Tab one"},{"location":"coreconcepts/hello_world/#tab-two","text":"Go to 0.0.0.0:8001 . Enter Bob into the Enter your instance ID text box.","title":"Tab two"},{"location":"coreconcepts/hello_world/#tab-one-alice","text":"Create a person entry with your name:","title":"Tab one --- Alice"},{"location":"coreconcepts/hello_world/#tab-two-bob","text":"Copy the address from the Alice tab and retrieve the person entry: Hooray! Alice and Bob are now able to find each other's information on the DHT","title":"Tab two --- Bob"},{"location":"coreconcepts/simple_micro_blog/","text":"Simple Micro Blog tutorial \u00b6 Welcome to the Simple Micro blog tutorial in the Core Concepts tutorial series. The aim of this tutorial is to show how entries can be linked to each other in a Holochain app. A link is simply a relationship between two entries. It's a useful way to find some data from something you already know. For example, you could link from your user's agent ID entry to their blog posts. You will be building on the previous Hello World tutorial and making a super simple blog app. The app's users will be able to post a blog post and then retrieve other users' posts. DNA hash \u00b6 The way you run your conductor has changed from hc run to calling holochain directly. As a consequence, the hash of your app's DNA now lives in the conductor-config.toml file. However, anytime you change your code and run hc package the hash will be different. So you will need to update the conductor-config.toml file. Enter the nix-shell: nix-shell https://holochain.love Package your app: hc package Copy the DNA hash (example shown): DNA hash: QmfKyAk2jXgESca2zju6QbkLqUM1xEjqDsmHRgRxoFp39q Update the conductor-config.toml dna hash: [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<new_dna_hash>\" Post \u00b6 We will store our posts as a Post struct that holds a message of type String , a timestamp of type u64 , and an author ID of type Address . We're done with the Hello World tutorial, so remove the Person struct and add the Post struct: Entry \u00b6 Update the person entry type definition to post : Agent ID \u00b6 #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Agent { id : String , } Now you have a post entry but you also need some way to find the posts an agent makes. To do this you can create an agent 'anchor' entry which you will use to link to the posts that the user makes. An anchor is a simple string whose only purpose is to be an easy-to-find entry to attach links to. Define an agent anchor entry type by adding the following lines below the post_entry_def . Add an agent_entry_def function which creates an entry type for the agent: #[entry_def] fn agent_entry_def () -> ValidatingEntryType { Start the entry! macro for the agent entry: entry ! ( name : \"agent\" , description : \"Hash of agent\" , Set sharing to public so other agents can find this agent's anchor (and hence their posts): sharing : Sharing :: Public , Add basic validation to make sure this is the Agent type that is passed in: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Agent >| { Ok (()) }, Now you want to be able to link this agent entry to the post entry. Start out with the to! link macro, which lets you create link definitions that link from this entry type to another entry type: links : [ to ! ( Define a link type from this entry to the post entry called author_post : \"post\" , link_type : \"author_post\" , Add empty validation for this link: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: LinkValidationData | { Ok (()) } ) ] ) } Create a post \u00b6 Remove the create_person function. You need a function for creating a new post. Think about the ingredients that might go into the Post structure: a message, a timestamp, and and the author's ID. The message will come from the UI. For simplicity the timestamp will come from the UI as well. Time is a pretty tricky concept in the distributed world and requires careful planning. The author's ID will come from the special constant hdk::AGENT_ADDRESS , which you can access from your zome functions. Why do I have to specify a timestamp and author? Aren't they already in the entry's header? \u00b6 If two agents publish entries with identical type and content, they'll have the same address on the DHT. That means that, for all purposes, there's only one entry with two authors. This is fine for some cases. But it causes problems in a microblog. When one author wants to delete an existing message, does the other author's copy get deleted too? Adding a timestamp and author ID makes the two posts distinct and gives them their own addresses. Add a public create_post function that takes a message as a String and a timestamp as a u64 : #[zome_fn( \"hc_public\" )] pub fn create_post ( message : String , timestamp : u64 ) -> ZomeApiResult < Address > { Create the Post using the message, timestamp, and author's address: let post = Post { message , timestamp , author_id : hdk :: AGENT_ADDRESS . clone (), }; Create the Agent struct from the AGENT_ADDRESS , turn it into an Entry and commit it: let agent_id = Agent { id : hdk :: AGENT_ADDRESS . clone (). into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: commit_entry ( & entry ) ? ; Commit the post entry: let entry = Entry :: App ( \"post\" . into (), post . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Create an author_post link from the agent to the post: hdk :: link_entries ( & agent_address , & address , \"author_post\" , \"\" ) ? ; Return everything is Ok with the new post's address: Ok ( address ) } Retrieve all of a user's posts \u00b6 Add the retrieve_posts public function that takes an author address and returns a vector of posts: #[zome_fn( \"hc_public\" )] fn retrieve_posts ( author_address : Address ) -> ZomeApiResult < Vec < Post >> { Create an Agent struct from the passed address, turn it into an Entry , and calculate its address: let agent_id = Agent { id : author_address . into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: entry_address ( & entry ) ? ; Get all the author_post links from the agent's address and load them as the Post type: hdk :: utils :: get_links_and_load_type ( & agent_address , LinkMatch :: Exactly ( \"author_post\" ), LinkMatch :: Any , ) } (Note that because you've already told Rust that this function is going to return a vector of posts, the compiler will tell get_links_and_load_type what type to use in the conversion.) We're using a new directive, link::LinkMatch . You'll need to add it to your use statements at the top of the file: use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , link :: LinkMatch , }; Get the agent's ID \u00b6 As a user, you will need some way of getting your own agent's ID in the UI later so that you can pass it to others. Then they can try getting your posts. Add a public get_agent_id function that returns an Address : #[zome_fn( \"hc_public\" )] fn get_agent_id () -> ZomeApiResult < Address > { For this app you can use the agent's address as their ID, because that's what we're storing in the agent anchor entries: Ok ( hdk :: AGENT_ADDRESS . clone ()) } Show the agent's ID in the UI \u00b6 Let's start on the UI. Go to your GUI folder and open up the index.html file. To make it easy to pass around agent ID, you can display the ID for the instance that each GUI is currently targeting. This should happen when the page loads and when the instance ID changes. Add an onload event to the body that will call the get_agent_id function when the page loads: < body onload = \"get_agent_id()\" > Add an onfocusout event to the instance text box that will call the same function when unfocused: < input type = \"text\" id = \"instance\" onfocusout = \"get_agent_id()\" placeholder = \"Enter your instance ID\" > Now open up the hello.js file and add the get_agent_id function: function get_agent_id () { Get the instance value and set up a zome call connection: var instance = document . getElementById ( 'instance' ). value ; holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { Call the get_agent_id zome function and then update the agent_id element with the result: callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) } Update the UI to allow posts to be created \u00b6 Back in index.html turn the \"create person\" HTML into a post entry widget. Use a textarea , call the create_post function, and update all the labels and IDs: Update the UI to retrieve an agent's posts \u00b6 Update the \"retrieve person\" HTML to retrieve posts: Call create_post from JavaScript \u00b6 In the hello.js file add the create_post function that your HTML calls: function create_post () { Get the post message and instance ID: var message = document . getElementById ( 'post' ). value ; var instance = document . getElementById ( 'instance' ). value ; Get the current timestamp: var timestamp = Date . now (); Make a zome call to create_post with the message and timestamp: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'create_post' )({ message : message , timestamp : timestamp }). then (( result ) => update_element ( result , 'post_address' )) }) } Update the posts list dynamically \u00b6 Add an empty list below the post_agent_id text box: < ul id = \"posts_output\" ></ ul > In the hello.js file add the following lines to update the posts_output dynamically. Add the display_posts function: function display_posts ( result ) { Get the posts_output HTML element: var list = document . getElementById ( 'posts_output' ); Wipe the current contents of the list, if any: list . innerHTML = \"\" ; Parse the zome function's result as JSON: var output = JSON . parse ( result ); Sort the posts by their timestamps: var posts = output . Ok . sort (( a , b ) => a . timestamp - b . timestamp ); For each post add a <li> element that contains the post's message: for ( post of posts ) { var node = document . createElement ( \"LI\" ); var textnode = document . createTextNode ( post . message ); node . appendChild ( textnode ); list . appendChild ( node ); } } Get this agent's ID \u00b6 Add the get_agent_id function: function get_agent_id () { var instance = document . getElementById ( 'instance' ). value ; Call the get_agent_id zome function and update the agent_id element: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) } Retrieve an agent's posts \u00b6 This is very similar to retrieve_person , so just update that function:","title":"Simple Micro Blog tutorial"},{"location":"coreconcepts/simple_micro_blog/#simple-micro-blog-tutorial","text":"Welcome to the Simple Micro blog tutorial in the Core Concepts tutorial series. The aim of this tutorial is to show how entries can be linked to each other in a Holochain app. A link is simply a relationship between two entries. It's a useful way to find some data from something you already know. For example, you could link from your user's agent ID entry to their blog posts. You will be building on the previous Hello World tutorial and making a super simple blog app. The app's users will be able to post a blog post and then retrieve other users' posts.","title":"Simple Micro Blog tutorial"},{"location":"coreconcepts/simple_micro_blog/#dna-hash","text":"The way you run your conductor has changed from hc run to calling holochain directly. As a consequence, the hash of your app's DNA now lives in the conductor-config.toml file. However, anytime you change your code and run hc package the hash will be different. So you will need to update the conductor-config.toml file. Enter the nix-shell: nix-shell https://holochain.love Package your app: hc package Copy the DNA hash (example shown): DNA hash: QmfKyAk2jXgESca2zju6QbkLqUM1xEjqDsmHRgRxoFp39q Update the conductor-config.toml dna hash: [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<new_dna_hash>\"","title":"DNA hash"},{"location":"coreconcepts/simple_micro_blog/#post","text":"We will store our posts as a Post struct that holds a message of type String , a timestamp of type u64 , and an author ID of type Address . We're done with the Hello World tutorial, so remove the Person struct and add the Post struct:","title":"Post"},{"location":"coreconcepts/simple_micro_blog/#entry","text":"Update the person entry type definition to post :","title":"Entry"},{"location":"coreconcepts/simple_micro_blog/#agent-id","text":"#[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] pub struct Agent { id : String , } Now you have a post entry but you also need some way to find the posts an agent makes. To do this you can create an agent 'anchor' entry which you will use to link to the posts that the user makes. An anchor is a simple string whose only purpose is to be an easy-to-find entry to attach links to. Define an agent anchor entry type by adding the following lines below the post_entry_def . Add an agent_entry_def function which creates an entry type for the agent: #[entry_def] fn agent_entry_def () -> ValidatingEntryType { Start the entry! macro for the agent entry: entry ! ( name : \"agent\" , description : \"Hash of agent\" , Set sharing to public so other agents can find this agent's anchor (and hence their posts): sharing : Sharing :: Public , Add basic validation to make sure this is the Agent type that is passed in: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Agent >| { Ok (()) }, Now you want to be able to link this agent entry to the post entry. Start out with the to! link macro, which lets you create link definitions that link from this entry type to another entry type: links : [ to ! ( Define a link type from this entry to the post entry called author_post : \"post\" , link_type : \"author_post\" , Add empty validation for this link: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: LinkValidationData | { Ok (()) } ) ] ) }","title":"Agent ID"},{"location":"coreconcepts/simple_micro_blog/#create-a-post","text":"Remove the create_person function. You need a function for creating a new post. Think about the ingredients that might go into the Post structure: a message, a timestamp, and and the author's ID. The message will come from the UI. For simplicity the timestamp will come from the UI as well. Time is a pretty tricky concept in the distributed world and requires careful planning. The author's ID will come from the special constant hdk::AGENT_ADDRESS , which you can access from your zome functions.","title":"Create a post"},{"location":"coreconcepts/simple_micro_blog/#why-do-i-have-to-specify-a-timestamp-and-author-arent-they-already-in-the-entrys-header","text":"If two agents publish entries with identical type and content, they'll have the same address on the DHT. That means that, for all purposes, there's only one entry with two authors. This is fine for some cases. But it causes problems in a microblog. When one author wants to delete an existing message, does the other author's copy get deleted too? Adding a timestamp and author ID makes the two posts distinct and gives them their own addresses. Add a public create_post function that takes a message as a String and a timestamp as a u64 : #[zome_fn( \"hc_public\" )] pub fn create_post ( message : String , timestamp : u64 ) -> ZomeApiResult < Address > { Create the Post using the message, timestamp, and author's address: let post = Post { message , timestamp , author_id : hdk :: AGENT_ADDRESS . clone (), }; Create the Agent struct from the AGENT_ADDRESS , turn it into an Entry and commit it: let agent_id = Agent { id : hdk :: AGENT_ADDRESS . clone (). into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: commit_entry ( & entry ) ? ; Commit the post entry: let entry = Entry :: App ( \"post\" . into (), post . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Create an author_post link from the agent to the post: hdk :: link_entries ( & agent_address , & address , \"author_post\" , \"\" ) ? ; Return everything is Ok with the new post's address: Ok ( address ) }","title":"Why do I have to specify a timestamp and author? Aren't they already in the entry's header?"},{"location":"coreconcepts/simple_micro_blog/#retrieve-all-of-a-users-posts","text":"Add the retrieve_posts public function that takes an author address and returns a vector of posts: #[zome_fn( \"hc_public\" )] fn retrieve_posts ( author_address : Address ) -> ZomeApiResult < Vec < Post >> { Create an Agent struct from the passed address, turn it into an Entry , and calculate its address: let agent_id = Agent { id : author_address . into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: entry_address ( & entry ) ? ; Get all the author_post links from the agent's address and load them as the Post type: hdk :: utils :: get_links_and_load_type ( & agent_address , LinkMatch :: Exactly ( \"author_post\" ), LinkMatch :: Any , ) } (Note that because you've already told Rust that this function is going to return a vector of posts, the compiler will tell get_links_and_load_type what type to use in the conversion.) We're using a new directive, link::LinkMatch . You'll need to add it to your use statements at the top of the file: use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , link :: LinkMatch , };","title":"Retrieve all of a user's posts"},{"location":"coreconcepts/simple_micro_blog/#get-the-agents-id","text":"As a user, you will need some way of getting your own agent's ID in the UI later so that you can pass it to others. Then they can try getting your posts. Add a public get_agent_id function that returns an Address : #[zome_fn( \"hc_public\" )] fn get_agent_id () -> ZomeApiResult < Address > { For this app you can use the agent's address as their ID, because that's what we're storing in the agent anchor entries: Ok ( hdk :: AGENT_ADDRESS . clone ()) }","title":"Get the agent's ID"},{"location":"coreconcepts/simple_micro_blog/#show-the-agents-id-in-the-ui","text":"Let's start on the UI. Go to your GUI folder and open up the index.html file. To make it easy to pass around agent ID, you can display the ID for the instance that each GUI is currently targeting. This should happen when the page loads and when the instance ID changes. Add an onload event to the body that will call the get_agent_id function when the page loads: < body onload = \"get_agent_id()\" > Add an onfocusout event to the instance text box that will call the same function when unfocused: < input type = \"text\" id = \"instance\" onfocusout = \"get_agent_id()\" placeholder = \"Enter your instance ID\" > Now open up the hello.js file and add the get_agent_id function: function get_agent_id () { Get the instance value and set up a zome call connection: var instance = document . getElementById ( 'instance' ). value ; holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { Call the get_agent_id zome function and then update the agent_id element with the result: callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) }","title":"Show the agent's ID in the UI"},{"location":"coreconcepts/simple_micro_blog/#update-the-ui-to-allow-posts-to-be-created","text":"Back in index.html turn the \"create person\" HTML into a post entry widget. Use a textarea , call the create_post function, and update all the labels and IDs:","title":"Update the UI to allow posts to be created"},{"location":"coreconcepts/simple_micro_blog/#update-the-ui-to-retrieve-an-agents-posts","text":"Update the \"retrieve person\" HTML to retrieve posts:","title":"Update the UI to retrieve an agent's posts"},{"location":"coreconcepts/simple_micro_blog/#call-create_post-from-javascript","text":"In the hello.js file add the create_post function that your HTML calls: function create_post () { Get the post message and instance ID: var message = document . getElementById ( 'post' ). value ; var instance = document . getElementById ( 'instance' ). value ; Get the current timestamp: var timestamp = Date . now (); Make a zome call to create_post with the message and timestamp: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'create_post' )({ message : message , timestamp : timestamp }). then (( result ) => update_element ( result , 'post_address' )) }) }","title":"Call create_post from JavaScript"},{"location":"coreconcepts/simple_micro_blog/#update-the-posts-list-dynamically","text":"Add an empty list below the post_agent_id text box: < ul id = \"posts_output\" ></ ul > In the hello.js file add the following lines to update the posts_output dynamically. Add the display_posts function: function display_posts ( result ) { Get the posts_output HTML element: var list = document . getElementById ( 'posts_output' ); Wipe the current contents of the list, if any: list . innerHTML = \"\" ; Parse the zome function's result as JSON: var output = JSON . parse ( result ); Sort the posts by their timestamps: var posts = output . Ok . sort (( a , b ) => a . timestamp - b . timestamp ); For each post add a <li> element that contains the post's message: for ( post of posts ) { var node = document . createElement ( \"LI\" ); var textnode = document . createTextNode ( post . message ); node . appendChild ( textnode ); list . appendChild ( node ); } }","title":"Update the posts list dynamically"},{"location":"coreconcepts/simple_micro_blog/#get-this-agents-id","text":"Add the get_agent_id function: function get_agent_id () { var instance = document . getElementById ( 'instance' ). value ; Call the get_agent_id zome function and update the agent_id element: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) }","title":"Get this agent's ID"},{"location":"coreconcepts/simple_micro_blog/#retrieve-an-agents-posts","text":"This is very similar to retrieve_person , so just update that function:","title":"Retrieve an agent's posts"}]}