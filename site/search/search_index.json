{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Some documentation \u00b6 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tellus augue, ullamcorper id hendrerit vitae, pretium eu erat. Morbi id mattis tortor. Sed ac augue nisl. Nam euismod tortor auctor porttitor consequat. Suspendisse finibus risus massa, at semper risus luctus vitae. Duis eu fringilla lacus. In faucibus varius nisl volutpat varius. Vestibulum ligula lacus, ullamcorper sed viverra vel, blandit nec lacus. Duis nec lorem eget justo porta ornare. Mauris dignissim varius faucibus. In hac habitasse platea dictumst. Duis rhoncus nisl urna, sit amet facilisis lectus dapibus sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Quisque id massa vitae libero accumsan accumsan. import tensorflow as tf #[init] fn init () { Ok (()) } #[init] fn init() { Ok(()) } #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct MyEntry { content : String , } #[zome] mod my_zome { #[init] fn init () { Ok (()) } #[entry_def] fn my_entry_def () -> ValidatingEntryType { entry ! ( name : \"my_entry\" , description : \"this is a same entry defintion\" , sharing : Sharing :: Public , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < MyEntry >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn create_my_entry ( entry : MyEntry ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"my_entry\" . into (), entry . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn get_my_entry ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } } Some more docs \u00b6 Etiam a velit et erat vulputate sollicitudin. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Morbi ut turpis est. Vestibulum pharetra, augue eu lobortis dapibus, libero lectus semper lectus, non cursus erat tellus a lorem. Pellentesque in orci vel turpis tristique varius non a libero. Nullam quis pellentesque odio, ac consequat ipsum. Nam a nibh et tellus interdum sagittis ut eu magna. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce luctus tellus sed arcu maximus, ut aliquam turpis tristique. Duis ut sollicitudin tortor, ac rhoncus augue. Nullam hendrerit imperdiet tincidunt. Nunc tincidunt tortor diam, vel tempor ipsum sagittis sit amet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur nec accumsan dui. Phasellus rutrum mollis dui vitae convallis. Maecenas vel rhoncus ligula, condimentum pretium quam. Vestibulum molestie porttitor congue. Pellentesque posuere purus et nisi lacinia posuere. Praesent tortor eros, iaculis vel massa id, commodo pellentesque neque. Mauris in turpis odio. Ut egestas purus elit, a malesuada ante eleifend in. Nam quis mollis leo. Nunc feugiat enim sed aliquam sagittis. Nunc eu nibh et nibh cursus tincidunt et et quam. Maecenas vitae risus vitae tellus suscipit faucibus non vitae erat. Morbi tristique eleifend augue, id condimentum nisi sagittis in. Even more docs \u00b6 Vestibulum sollicitudin sem in orci dapibus, a accumsan dolor hendrerit. Ut varius est et ex euismod tempor. Nulla dignissim risus et metus faucibus, quis pulvinar elit semper. Aenean vestibulum nisi dignissim ligula dapibus eleifend. Nullam sollicitudin enim eu mi efficitur, vel suscipit augue euismod. Morbi eget rutrum erat. Proin non nunc nec leo tempus eleifend. Pellentesque nisl felis, consequat sit amet dolor ac, bibendum lobortis augue. Etiam sit amet nisi consectetur, congue neque a, pellentesque ligula. Curabitur quis velit felis. Aenean condimentum malesuada blandit. Vestibulum varius ultricies malesuada. #[validate_agent] pub fn validate_agent(validation_data: EntryValidationData<AgentId>) { Ok(()) }","title":"Some documentation"},{"location":"#some-documentation","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tellus augue, ullamcorper id hendrerit vitae, pretium eu erat. Morbi id mattis tortor. Sed ac augue nisl. Nam euismod tortor auctor porttitor consequat. Suspendisse finibus risus massa, at semper risus luctus vitae. Duis eu fringilla lacus. In faucibus varius nisl volutpat varius. Vestibulum ligula lacus, ullamcorper sed viverra vel, blandit nec lacus. Duis nec lorem eget justo porta ornare. Mauris dignissim varius faucibus. In hac habitasse platea dictumst. Duis rhoncus nisl urna, sit amet facilisis lectus dapibus sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Quisque id massa vitae libero accumsan accumsan. import tensorflow as tf #[init] fn init () { Ok (()) } #[init] fn init() { Ok(()) } #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct MyEntry { content : String , } #[zome] mod my_zome { #[init] fn init () { Ok (()) } #[entry_def] fn my_entry_def () -> ValidatingEntryType { entry ! ( name : \"my_entry\" , description : \"this is a same entry defintion\" , sharing : Sharing :: Public , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < MyEntry >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn create_my_entry ( entry : MyEntry ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"my_entry\" . into (), entry . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn get_my_entry ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } }","title":"Some documentation"},{"location":"#some-more-docs","text":"Etiam a velit et erat vulputate sollicitudin. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Morbi ut turpis est. Vestibulum pharetra, augue eu lobortis dapibus, libero lectus semper lectus, non cursus erat tellus a lorem. Pellentesque in orci vel turpis tristique varius non a libero. Nullam quis pellentesque odio, ac consequat ipsum. Nam a nibh et tellus interdum sagittis ut eu magna. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce luctus tellus sed arcu maximus, ut aliquam turpis tristique. Duis ut sollicitudin tortor, ac rhoncus augue. Nullam hendrerit imperdiet tincidunt. Nunc tincidunt tortor diam, vel tempor ipsum sagittis sit amet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur nec accumsan dui. Phasellus rutrum mollis dui vitae convallis. Maecenas vel rhoncus ligula, condimentum pretium quam. Vestibulum molestie porttitor congue. Pellentesque posuere purus et nisi lacinia posuere. Praesent tortor eros, iaculis vel massa id, commodo pellentesque neque. Mauris in turpis odio. Ut egestas purus elit, a malesuada ante eleifend in. Nam quis mollis leo. Nunc feugiat enim sed aliquam sagittis. Nunc eu nibh et nibh cursus tincidunt et et quam. Maecenas vitae risus vitae tellus suscipit faucibus non vitae erat. Morbi tristique eleifend augue, id condimentum nisi sagittis in.","title":"Some more docs"},{"location":"#even-more-docs","text":"Vestibulum sollicitudin sem in orci dapibus, a accumsan dolor hendrerit. Ut varius est et ex euismod tempor. Nulla dignissim risus et metus faucibus, quis pulvinar elit semper. Aenean vestibulum nisi dignissim ligula dapibus eleifend. Nullam sollicitudin enim eu mi efficitur, vel suscipit augue euismod. Morbi eget rutrum erat. Proin non nunc nec leo tempus eleifend. Pellentesque nisl felis, consequat sit amet dolor ac, bibendum lobortis augue. Etiam sit amet nisi consectetur, congue neque a, pellentesque ligula. Curabitur quis velit felis. Aenean condimentum malesuada blandit. Vestibulum varius ultricies malesuada. #[validate_agent] pub fn validate_agent(validation_data: EntryValidationData<AgentId>) { Ok(()) }","title":"Even more docs"},{"location":"some/","text":"","title":"Some"},{"location":"coreconcepts/hello_gui/","text":"Hello Test Tutorial \u00b6 Welcome to the Hello Test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous Hello Holo tutorial, so make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used. Understand the tests \u00b6 When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in JavaScript and use the Holochain testing framework Diorama , along with a popular test harness called Tape . You can run them with Node.JS , a runtime that lets you execute JavaScript in the terminal. Open up the hello_holo/test/index.js in your favourite text editor. Have a look through the code. Imports required to do testing: const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) This is a catch-all error logger that will let you know if a Promise fails and there's no error handler to hear it. Promise s are a way of simplifying complex asynchronous code, and Diorama uses a lot of them. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled DNA. const dnaPath = path . join ( __dirname , \"../dist/hello_holo.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'hello_holo' ) Setup a testing scenario. This creates two agents: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that Holochain generated based on the my_entry struct and the zome functions that work with it. We removed them in our Hello Holo tutorial, so let's remove the test. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run () Create a test scenario \u00b6 Tests are organized by creating scenarios. Think of them as a series of actions that the user or group of users take when interacting with your app. For this test you simply want to get the Alice user to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function, passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is okay: t . ok ( result . Ok ); Check that the result matches what you expected: t . deepEqual ( result , { Ok : 'Hello Holo' }) }) Run the test \u00b6 Now in the hello_helo directory, run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output. But if everything went okay, then right at the end you will see: # tests 2 # pass 2 # ok Congratulations; you have tested your first Holochain app. Look at you go! :sparkles:","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_gui/#hello-test-tutorial","text":"Welcome to the Hello Test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous Hello Holo tutorial, so make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used.","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_gui/#understand-the-tests","text":"When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in JavaScript and use the Holochain testing framework Diorama , along with a popular test harness called Tape . You can run them with Node.JS , a runtime that lets you execute JavaScript in the terminal. Open up the hello_holo/test/index.js in your favourite text editor. Have a look through the code. Imports required to do testing: const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) This is a catch-all error logger that will let you know if a Promise fails and there's no error handler to hear it. Promise s are a way of simplifying complex asynchronous code, and Diorama uses a lot of them. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled DNA. const dnaPath = path . join ( __dirname , \"../dist/hello_holo.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'hello_holo' ) Setup a testing scenario. This creates two agents: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that Holochain generated based on the my_entry struct and the zome functions that work with it. We removed them in our Hello Holo tutorial, so let's remove the test. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run ()","title":"Understand the tests"},{"location":"coreconcepts/hello_gui/#create-a-test-scenario","text":"Tests are organized by creating scenarios. Think of them as a series of actions that the user or group of users take when interacting with your app. For this test you simply want to get the Alice user to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function, passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is okay: t . ok ( result . Ok ); Check that the result matches what you expected: t . deepEqual ( result , { Ok : 'Hello Holo' }) })","title":"Create a test scenario"},{"location":"coreconcepts/hello_gui/#run-the-test","text":"Now in the hello_helo directory, run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output. But if everything went okay, then right at the end you will see: # tests 2 # pass 2 # ok Congratulations; you have tested your first Holochain app. Look at you go! :sparkles:","title":"Run the test"},{"location":"coreconcepts/hello_holo/","text":"Hello Holo Tutorial \u00b6 Let's begin with the classic Hello ~~World~~ Holo tutorial! You will see it's super easy to create a distributed application with Holochain. Setup \u00b6 Complete the installation guide . This will give you an app development environment including the Holochain developer tool hc . Open up a terminal (command prompt in Windows). Enter the development environment. macOS/Linux (you'll remember this command from the installation tutorial): bash $ nix-shell https://holochain.love Windows (do this in the place where you installed Holochain): ```cmd vagrant up vagrant ssh nix-shell https://holochain.love ``` Initializing your new app \u00b6 Pick a new home for all your future amazing Holochain applications to live. Something super creative like home_directory/holochain/ . Then create a coreconcepts folder for this tutorial series: cd ~ mkdir holochain cd holochain mkdir coreconcepts Time to put the holochain command line tool ( hc ) to work and make your app. Initialize a new app and enter the app directory: $ hc init hello_tuts $ cd hello_tuts Compile \u00b6 It's an always good to frequently compile your app. That way you catch any mistakes early on. Give it a go by asking hc to package it up: $ hc package Packaging your app means you are compiling the code into a DNA file and getting it ready to be run. You should see a successful compilation like this: Created DNA package file at \"/Users/username/holochain/testing_tuts/hello_holo/dist/hello_holo.dna.json\" DNA hash: QmY 7 rhg 4 sf 6 xqQMRL 1 u 1 CnXVgmamTfxC 59 c 9 RaoFqM 2 eRs Zome \u00b6 Your app doesn't really do too much right now because it needs a zome . A zome is Holochain's way of organizing code into nice units that perform a certain task (like saying hello). Generate a zome called hello inside the zome's folder: $ hc generate zomes/hello rust-proc Compile \u00b6 $ hc package Zomes can take a little while to compile the first time. Compiling will be much faster the next time you do it. Feel free to move on with the tutorial while your app compiles. If all went well you should see: > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Compiling hello v0.1.0 ( /Users/username/holochain/core_concepts/hello_hollo/zomes/hello/code ) Finished release [ optimized ] target ( s ) in 11 .95s > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Finished release [ optimized ] target ( s ) in 0 .50s Created DNA package file at \"/Users/username/holochain/core_concepts/hello_hollo/dist/hello_hollo.dna.json\" DNA hash: QmdNyxke1Z9Kunws4WUXHnt4cdKQnPogC7YPpfQx67fo1z Folder layout \u00b6 Look at the folder layout \u00b6 Open the lib.rs file \u00b6 The zome is a Rust project and makes use of macros so you can avoid writing a lot of boilerplate code. The main file you will be editing is hello_hollo/zomes/code/lib.rs . The following are all the imports. You are telling Rust, \"hey, I need things from all these crates in order to do my job.\" #S:INCLUDE #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; Next are the use statements. They are saying, \"I want to use these specific things from the above crates.\" #S:SKIP use hdk :: { entry_definition :: ValidatingEntryType , error :: ZomeApiResult , }; use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , }; use hdk :: holochain_json_api :: { json :: JsonString , error :: JsonError }; use hdk :: holochain_persistence_api :: { cas :: content :: Address }; use hdk_proc_macros :: zome ; You only need these use statements for this tutorial so remove the rest. #S:INCLUDE use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; There are a few sections of generated code that are not useful for this tutorial. Remove the following piece of code: #S:SKIP #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct MyEntry { content : String , } The my_zome module is where all your zome code live. #[zome] is a procedural macro that says that the following module defines all the things that Holochain should know about this zome. It saves you writing lots of code. Change it to hello_zome for this tutorial series: #S:INCLUDE #[zome] mod hello_zome { The init function is run when a user starts the app for the first time. Every zome defines this function so it can do some initial setup tasks. In this zome it doesn't do anything. #[init] fn init () { Return success with the empty value () . In Rust () is called the unit type and is similar (though not identical) to a void type in other languages. Ok (()) } Remove the following template code: #S:SKIP #[entry_def] fn my_entry_def () -> ValidatingEntryType { entry ! ( name : \"my_entry\" , description : \"this is a same entry defintion\" , sharing : Sharing :: Public , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < MyEntry >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn create_my_entry ( entry : MyEntry ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"my_entry\" . into (), entry . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn get_my_entry ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } This required function is run at application start too, once by the new user and once by the existing peers. It checks that the user is allowed to join the network. In this case it gives everyone a free pass. #S:INCLUDE #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } A note about return values \u00b6 You'll often see Rust functions returning some sort of Result value. This is a special Rust type that can either be Ok(some_value) to show that the function succeeded or Err(some_error) to report an error. All required Holochain functions, such as init and validators, are expected return a special result type called ZomeApiResult , which shuttles data back and forth between your app and the conductor. It also automatically converts data to JSON and back, so it makes sense to use it in your public functions too. Say hello :) \u00b6 Now tell the zome to return Hello Holo from a public function. Locate the init function: #S:SKIP fn init () { Ok (()) } You're going to put your public zome function after it. The hc_public procedural macro will turn the function directly below it into a public function that GUIs, other zomes, and DNAs can call. It takes note of the function's name, the parameters it accepts, and the type of value it returns, so Holochain can call it properly. Add the hc_public macro: #S:INCLUDE #[zome_fn( \"hc_public\" )] The function hello_holo takes no arguments and returns a Holochain result type. We're also telling Holochain that if the result is Ok then it will contain some sort of string. Start the function: fn hello_holo () -> ZomeApiResult < String > { Return an Ok result that contains our greeting. into() is a bit of Rust oddness that just means \"turn this slice into a String \": Ok ( \"Hello Holo\" . into ()) } Close the zome: } Compile \u00b6 If you do find any errors, remember to fix them before moving on. You can always get help on the forum . $ hc package Talk to your app \u00b6 Time to run your app in HTTP mode so you can talk to it. Run your app with the following command: $ hc run -i http You can send a POST message to your app using curl , a little command for making HTTP requests. (It's included in the Holochain dev environment.) You will need to open a new terminal window and enter the nix-shell again: $ nix-shell https://holochain.love Enter the following request, which will call the hello_holo function and return the result: $ curl -X POST -H \"Content-Type: application/json\" -d '{\"id\": \"0\", \"jsonrpc\": \"2.0\", \"method\": \"call\", \"params\": {\"instance_id\": \"test-instance\", \"zome\": \"hello\", \"function\": \"hello_holo\", \"args\": {} }}' http://127.0.0.1:8888 And you should get back your string from the hello_holo function: { \"jsonrpc\" : \"2.0\" , \"result\" : \"{\\\"Ok\\\":\\\"Hello Holo\\\"}\" , \"id\" : \"0\" } Congratulations --- you have created your first distributed Holochain application! :rocket:","title":"Hello Holo Tutorial"},{"location":"coreconcepts/hello_holo/#hello-holo-tutorial","text":"Let's begin with the classic Hello ~~World~~ Holo tutorial! You will see it's super easy to create a distributed application with Holochain.","title":"Hello Holo Tutorial"},{"location":"coreconcepts/hello_holo/#setup","text":"Complete the installation guide . This will give you an app development environment including the Holochain developer tool hc . Open up a terminal (command prompt in Windows). Enter the development environment. macOS/Linux (you'll remember this command from the installation tutorial): bash $ nix-shell https://holochain.love Windows (do this in the place where you installed Holochain): ```cmd vagrant up vagrant ssh nix-shell https://holochain.love ```","title":"Setup"},{"location":"coreconcepts/hello_holo/#initializing-your-new-app","text":"Pick a new home for all your future amazing Holochain applications to live. Something super creative like home_directory/holochain/ . Then create a coreconcepts folder for this tutorial series: cd ~ mkdir holochain cd holochain mkdir coreconcepts Time to put the holochain command line tool ( hc ) to work and make your app. Initialize a new app and enter the app directory: $ hc init hello_tuts $ cd hello_tuts","title":"Initializing your new app"},{"location":"coreconcepts/hello_holo/#compile","text":"It's an always good to frequently compile your app. That way you catch any mistakes early on. Give it a go by asking hc to package it up: $ hc package Packaging your app means you are compiling the code into a DNA file and getting it ready to be run. You should see a successful compilation like this: Created DNA package file at \"/Users/username/holochain/testing_tuts/hello_holo/dist/hello_holo.dna.json\" DNA hash: QmY 7 rhg 4 sf 6 xqQMRL 1 u 1 CnXVgmamTfxC 59 c 9 RaoFqM 2 eRs","title":"Compile"},{"location":"coreconcepts/hello_holo/#zome","text":"Your app doesn't really do too much right now because it needs a zome . A zome is Holochain's way of organizing code into nice units that perform a certain task (like saying hello). Generate a zome called hello inside the zome's folder: $ hc generate zomes/hello rust-proc","title":"Zome"},{"location":"coreconcepts/hello_holo/#compile_1","text":"$ hc package Zomes can take a little while to compile the first time. Compiling will be much faster the next time you do it. Feel free to move on with the tutorial while your app compiles. If all went well you should see: > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Compiling hello v0.1.0 ( /Users/username/holochain/core_concepts/hello_hollo/zomes/hello/code ) Finished release [ optimized ] target ( s ) in 11 .95s > cargo build --release --target = wasm32-unknown-unknown --target-dir = target Finished release [ optimized ] target ( s ) in 0 .50s Created DNA package file at \"/Users/username/holochain/core_concepts/hello_hollo/dist/hello_hollo.dna.json\" DNA hash: QmdNyxke1Z9Kunws4WUXHnt4cdKQnPogC7YPpfQx67fo1z","title":"Compile"},{"location":"coreconcepts/hello_holo/#folder-layout","text":"","title":"Folder layout"},{"location":"coreconcepts/hello_holo/#look-at-the-folder-layout","text":"","title":"Look at the folder layout"},{"location":"coreconcepts/hello_holo/#open-the-librs-file","text":"The zome is a Rust project and makes use of macros so you can avoid writing a lot of boilerplate code. The main file you will be editing is hello_hollo/zomes/code/lib.rs . The following are all the imports. You are telling Rust, \"hey, I need things from all these crates in order to do my job.\" #S:INCLUDE #![feature(proc_macro_hygiene)] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; extern crate holochain_json_derive ; Next are the use statements. They are saying, \"I want to use these specific things from the above crates.\" #S:SKIP use hdk :: { entry_definition :: ValidatingEntryType , error :: ZomeApiResult , }; use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , }; use hdk :: holochain_json_api :: { json :: JsonString , error :: JsonError }; use hdk :: holochain_persistence_api :: { cas :: content :: Address }; use hdk_proc_macros :: zome ; You only need these use statements for this tutorial so remove the rest. #S:INCLUDE use hdk :: { error :: ZomeApiResult , }; use hdk_proc_macros :: zome ; There are a few sections of generated code that are not useful for this tutorial. Remove the following piece of code: #S:SKIP #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct MyEntry { content : String , } The my_zome module is where all your zome code live. #[zome] is a procedural macro that says that the following module defines all the things that Holochain should know about this zome. It saves you writing lots of code. Change it to hello_zome for this tutorial series: #S:INCLUDE #[zome] mod hello_zome { The init function is run when a user starts the app for the first time. Every zome defines this function so it can do some initial setup tasks. In this zome it doesn't do anything. #[init] fn init () { Return success with the empty value () . In Rust () is called the unit type and is similar (though not identical) to a void type in other languages. Ok (()) } Remove the following template code: #S:SKIP #[entry_def] fn my_entry_def () -> ValidatingEntryType { entry ! ( name : \"my_entry\" , description : \"this is a same entry defintion\" , sharing : Sharing :: Public , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < MyEntry >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn create_my_entry ( entry : MyEntry ) -> ZomeApiResult < Address > { let entry = Entry :: App ( \"my_entry\" . into (), entry . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Ok ( address ) } #[zome_fn( \"hc_public\" )] fn get_my_entry ( address : Address ) -> ZomeApiResult < Option < Entry >> { hdk :: get_entry ( & address ) } This required function is run at application start too, once by the new user and once by the existing peers. It checks that the user is allowed to join the network. In this case it gives everyone a free pass. #S:INCLUDE #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) }","title":"Open the lib.rs file"},{"location":"coreconcepts/hello_holo/#a-note-about-return-values","text":"You'll often see Rust functions returning some sort of Result value. This is a special Rust type that can either be Ok(some_value) to show that the function succeeded or Err(some_error) to report an error. All required Holochain functions, such as init and validators, are expected return a special result type called ZomeApiResult , which shuttles data back and forth between your app and the conductor. It also automatically converts data to JSON and back, so it makes sense to use it in your public functions too.","title":"A note about return values"},{"location":"coreconcepts/hello_holo/#say-hello","text":"Now tell the zome to return Hello Holo from a public function. Locate the init function: #S:SKIP fn init () { Ok (()) } You're going to put your public zome function after it. The hc_public procedural macro will turn the function directly below it into a public function that GUIs, other zomes, and DNAs can call. It takes note of the function's name, the parameters it accepts, and the type of value it returns, so Holochain can call it properly. Add the hc_public macro: #S:INCLUDE #[zome_fn( \"hc_public\" )] The function hello_holo takes no arguments and returns a Holochain result type. We're also telling Holochain that if the result is Ok then it will contain some sort of string. Start the function: fn hello_holo () -> ZomeApiResult < String > { Return an Ok result that contains our greeting. into() is a bit of Rust oddness that just means \"turn this slice into a String \": Ok ( \"Hello Holo\" . into ()) } Close the zome: }","title":"Say hello :)"},{"location":"coreconcepts/hello_holo/#compile_2","text":"If you do find any errors, remember to fix them before moving on. You can always get help on the forum . $ hc package","title":"Compile"},{"location":"coreconcepts/hello_holo/#talk-to-your-app","text":"Time to run your app in HTTP mode so you can talk to it. Run your app with the following command: $ hc run -i http You can send a POST message to your app using curl , a little command for making HTTP requests. (It's included in the Holochain dev environment.) You will need to open a new terminal window and enter the nix-shell again: $ nix-shell https://holochain.love Enter the following request, which will call the hello_holo function and return the result: $ curl -X POST -H \"Content-Type: application/json\" -d '{\"id\": \"0\", \"jsonrpc\": \"2.0\", \"method\": \"call\", \"params\": {\"instance_id\": \"test-instance\", \"zome\": \"hello\", \"function\": \"hello_holo\", \"args\": {} }}' http://127.0.0.1:8888 And you should get back your string from the hello_holo function: { \"jsonrpc\" : \"2.0\" , \"result\" : \"{\\\"Ok\\\":\\\"Hello Holo\\\"}\" , \"id\" : \"0\" } Congratulations --- you have created your first distributed Holochain application! :rocket:","title":"Talk to your app"},{"location":"coreconcepts/hello_me/","text":"#S:EXTERNAL=hello_me.rs Hello Me \u00b6 Welcome back to another tutorial in the Core Concepts series. Today you will learn how to add an entry type to your zome and start writing entries to your source chain. Remember an entry is a piece of data in your source chain that has been validated. The design of today's app will be: Add a person entry type that stores information about a person. Expose the public function create_person for your UI to create and store a person entry. Expose a public function retrieve_person for your UI to retrieve a person entry. Add the UI components to interact with these functions. This tutorial builds on the previous tutorial so go back and complete that if you haven't already. Test first \u00b6 Let's start by writing a test so it's easy to see we have a working app before writing the UI. Open up your tutorial/test/index.js . This is how we left the testing scenario in the Hello Test tutorial: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here }) Add the new tests below t.deepEqual(result, { Ok: 'Hello Holo' }) . Add a call to the create_person function with a person whose name is Alice: const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); Check that the result of the call is Ok: t . ok ( create_result . Ok ); Add a call to the retrieve_person function with the address from the last call: const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that this call is Ok as well: t . ok ( retrieve_result . Ok ); This is the actual result we want at the end of the test. Check that the entry at the address is indeed Alice : t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Running the test \u00b6 Your test should now look like this: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) }) Obviously these tests will fail right now. Can you guess what the first failure will be? Let's have a look. Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Run the test: nix-shell ] hc test Note that this test might actually get stuck because we haven't put in the required functions yet. Press ctrl-c to exit a stuck test. Entry \u00b6 Open up your zomes/hello/code/src/lib.rs file. To add an entry into your source chain you start by telling Holochain what kinds of entry exist. First we'll create a struct to define the shape of the data. In a moment we will add a Person struct, but this is where to put it: #S:SKIP // <---- Add the person struct here. #[zome] mod hello_zome { Add the following lines. Allow this struct to be easily converted to and from JSON: #S:INCLUDE #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] Represent a person as a struct: pub struct Person { Represent their name as a String: name : String , } Look for the following lines inside the hello_zome mod. #[zome] mod hello_zome { #S:HIDE #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. Add the person_entry_def function, which tells Holochain about the person entry type: #[entry_def] fn person_entry_def () -> ValidatingEntryType { Add the entry! macro that lets you easily create a ValidatingEntryType : entry ! ( Give it the same name as the Person struct, just to be consistent. Entry types are usually in lowercase. Add the name and description of the entry: name : \"person\" , description : \"Person to say hello to\" , Entries of this type are just for this agent's eyes only, so set the entry sharing to private: sharing : Sharing :: Private , Add the validation_package function that says what is needed to validate this entry: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, Add the validation function that validates this entry. It returns that this entry is always Ok as long as it fits the shape of the Person struct: validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Now you can create actual person entries and store them on your source chain. A note on validation: Validation is very important. It is the \"rules of the game\" for your Holochain app. It is meaningful to emphasize that although we are returning Ok(()) that we are still validating that the data type checks as a Person with a name property containing a String . Essentially this rule says the person entry must be in this format. Add some use statements \u00b6 In the above code we have used a few types and macros that are not mentioned anywhere else. So the Rust compiler doesn't know where to find them yet. Add the following use statements: Compile \u00b6 TODO: The following code block should be collapsable Check your code matches this: #S:SKIP #![feature(proc_macro_hygiene)] #[macro_use] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; #[macro_use] extern crate holochain_json_derive ; use hdk :: { entry_definition :: ValidatingEntryType , error :: ZomeApiResult , }; use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , }; use hdk :: holochain_json_api :: { json :: JsonString , error :: JsonError , }; use hdk :: holochain_persistence_api :: { cas :: content :: Address }; use hdk_proc_macros :: zome ; #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } } Package the app (in the nix-shell) and check that there's no compile errors: nix-shell ] hc package Create a person \u00b6 Now you need a way for you UI to actually create a person entry. Holochain has a concept called hc_public which is a way of telling the runtime make this function available to call from outside this zome. Add the following lines below the previous person_entry_def function. Add a public function that takes a Person and returns a result with an Address : #S:INCLUDE #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { Create an entry from the passed argument: let entry = Entry :: App ( \"person\" . into (), person . into ()); Commit the entry to your local source chain: let address = hdk :: commit_entry ( & entry ) ? ; Return the Ok result with the new person entry's address: Ok ( address ) } Compile \u00b6 TODO: Add collapsable \"your code should look like this section\" Check for compile errors again: nix-shell ] hc package Retrieve person \u00b6 Lastly you need a way for your UI to get a person entry back from the source chain. Add the following lines below the create_person function. Add a public retrieve_person function that takes an Address and maybe returns an Entry (because it might not exist): #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { Get the entry from your local storage, asking for it by address: hdk :: get_entry ( & address ) } In Rust the last line is always returned. You do not need to explicitly say return . Test \u00b6 TODO: Add collapsable \"your code should look like this section\" Instead of directly compiling, you can run the test you wrote at the start (the test always compiles before it runs): nix-shell ] hc test If everything went smoothly you will see: 1 ..5 # tests 5 # pass 5 # ok UI \u00b6 Now you can move onto the modifying the UI to interact with zome functions you just created. First let's do some housekeeping and move the JavaScript from the previous tutorial into its own file. Go to the GUI project folder that you created in the Hello GUI tutorial: cd holochain/coreconcepts/gui Create a new hello.js file, open it in your favorite editor, and open the index.html alongside it. Move the everything inside the <script> tag into the hello.js : < script type = \"text/javascript\" > <!-- Everything from HERE to --> // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } function update_span ( result ) { var span = document . getElementById ( 'output' ); var output = JSON . parse ( result ); span . textContent = \" \" + output . Ok ; } <!-- HERE --> < /script> Add the src attribute to the <script> tag: < script type = \"text/javascript\" src = \"hello.js\" ></ script > Create person UI widget \u00b6 Let's start with the HTML elements to create a person. Look for the previous 'say hello' elements. < button onclick = \"hello()\" type = \"button\" > Say Hello </ button > < span > Response: </ span >< span id = \"output\" ></ span > <!-- Put the following lines here --> Below them, add a text box so the user can enter their name: < input type = \"text\" id = \"name\" placeholder = \"Enter your name :)\" >< br > Add a button that calls a (yet to be written) JavaScript function called create_person : < button onclick = \"create_person()\" type = \"button\" > Submit Name </ button > Add a span with the id address_output so you can render the result of this call: < div > Address: < span id = \"address_output\" ></ span ></ div > TODO: Add collapsable html code panel. Switch to your hello.js file \u00b6 Let's write the create_person function that will call your zome. Add the create_person function: function create_person () { Get the text box by its ID name and save the current text value into the name variable: var name = document . getElementById ( 'name' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call create_person in your hello zome and pass in the name variable as part of a person structure, then write the result to the console: callZome ( 'test-instance' , 'hello' , 'create_person' )({ person : { name : name } }). then (( result ) => console . log ( result , 'address_output' )) }) } Run the server and open a browser \u00b6 TODO: Add collapsable hello.js code panel. Go ahead and test your first call. Open a new terminal window and enter the nix-shell: nix-shell https://holochain.love Run the server: nix-shell ] python -m SimpleHTTPServer In your other terminal window package and run your zome: nix-shell ] hc package nix-shell ] hc run -p 8080 Now that both your UI server and your Holochain conductor server are running, open up a browser and go to 0.0.0.0:8000 . You should see the HTML elements you created: Open the developer console, enter your name, and press the \"Submit Name\" button. You should something similar to this: The address you see will probably be different, because you probably typed in your own name. Show the new entry's address \u00b6 First, a bit of refactoring. If you make the update_span function more generic, then you can reuse it for each element. Pass in the element's ID so that the function can be reused: Enter the browser \u00b6 Go back to your browser and refresh the page. This time when you enter your name and press Submit Name you will see the address show up: Retrieve a person entry and show it in the UI \u00b6 Back in the index.html file now. Add a text box so the user can enter the address that is returned from the create_person function: < input type = \"text\" id = \"address_in\" placeholder = \"Enter the entry address\" >< br > Add a button that calls the (yet to be written) retrieve_person JavaScript function: < button onclick = \"retrieve_person()\" type = \"button\" > Get Entry </ button > Add a span with the ID entry_output to display the person that is returned from the retrieve_person function: < div > Person: < span id = \"entry_output\" ></ span ></ div > Go to your hello.js file \u00b6 Add the retrieve_person function to call the zome function: function retrieve_person () { Get the value from the address_in text box: var address = document . getElementById ( 'address_in' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the retrieve_person public zome function and pass in the address then pass the result to update_person : callZome ( 'test-instance' , 'hello' , 'retrieve_person' )({ address : address }). then (( result ) => update_person ( result )) }) } Add the update_person function. It is very similar to update_element except that you need to parse the result and then parse the inner array. function update_person ( result ) { var person = document . getElementById ( 'entry_output' ); var output = JSON . parse ( result ); var output = JSON . parse ( output . Ok . App [ 1 ]); person . textContent = \" \" + output . name ; } #S:HIDE }","title":"Hello me"},{"location":"coreconcepts/hello_me/#hello-me","text":"Welcome back to another tutorial in the Core Concepts series. Today you will learn how to add an entry type to your zome and start writing entries to your source chain. Remember an entry is a piece of data in your source chain that has been validated. The design of today's app will be: Add a person entry type that stores information about a person. Expose the public function create_person for your UI to create and store a person entry. Expose a public function retrieve_person for your UI to retrieve a person entry. Add the UI components to interact with these functions. This tutorial builds on the previous tutorial so go back and complete that if you haven't already.","title":"Hello Me"},{"location":"coreconcepts/hello_me/#test-first","text":"Let's start by writing a test so it's easy to see we have a working app before writing the UI. Open up your tutorial/test/index.js . This is how we left the testing scenario in the Hello Test tutorial: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) // <---- Put your new tests here }) Add the new tests below t.deepEqual(result, { Ok: 'Hello Holo' }) . Add a call to the create_person function with a person whose name is Alice: const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); Check that the result of the call is Ok: t . ok ( create_result . Ok ); Add a call to the retrieve_person function with the address from the last call: const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that this call is Ok as well: t . ok ( retrieve_result . Ok ); This is the actual result we want at the end of the test. Check that the entry at the address is indeed Alice : t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }})","title":"Test first"},{"location":"coreconcepts/hello_me/#running-the-test","text":"Your test should now look like this: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { // Make a call to the `hello_holo` Zome function // passing no arguments. const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); // Make sure the result is ok. t . ok ( result . Ok ); // Check that the result matches what you expected. t . deepEqual ( result , { Ok : 'Hello Holo' }) const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) }) Obviously these tests will fail right now. Can you guess what the first failure will be? Let's have a look. Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Run the test: nix-shell ] hc test Note that this test might actually get stuck because we haven't put in the required functions yet. Press ctrl-c to exit a stuck test.","title":"Running the test"},{"location":"coreconcepts/hello_me/#entry","text":"Open up your zomes/hello/code/src/lib.rs file. To add an entry into your source chain you start by telling Holochain what kinds of entry exist. First we'll create a struct to define the shape of the data. In a moment we will add a Person struct, but this is where to put it: #S:SKIP // <---- Add the person struct here. #[zome] mod hello_zome { Add the following lines. Allow this struct to be easily converted to and from JSON: #S:INCLUDE #[derive(Serialize, Deserialize, Debug, DefaultJson, Clone)] Represent a person as a struct: pub struct Person { Represent their name as a String: name : String , } Look for the following lines inside the hello_zome mod. #[zome] mod hello_zome { #S:HIDE #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } /* --- Lines omitted -- */ #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } // <---- Add the following lines here. Add the person_entry_def function, which tells Holochain about the person entry type: #[entry_def] fn person_entry_def () -> ValidatingEntryType { Add the entry! macro that lets you easily create a ValidatingEntryType : entry ! ( Give it the same name as the Person struct, just to be consistent. Entry types are usually in lowercase. Add the name and description of the entry: name : \"person\" , description : \"Person to say hello to\" , Entries of this type are just for this agent's eyes only, so set the entry sharing to private: sharing : Sharing :: Private , Add the validation_package function that says what is needed to validate this entry: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, Add the validation function that validates this entry. It returns that this entry is always Ok as long as it fits the shape of the Person struct: validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } Now you can create actual person entries and store them on your source chain. A note on validation: Validation is very important. It is the \"rules of the game\" for your Holochain app. It is meaningful to emphasize that although we are returning Ok(()) that we are still validating that the data type checks as a Person with a name property containing a String . Essentially this rule says the person entry must be in this format.","title":"Entry"},{"location":"coreconcepts/hello_me/#add-some-use-statements","text":"In the above code we have used a few types and macros that are not mentioned anywhere else. So the Rust compiler doesn't know where to find them yet. Add the following use statements:","title":"Add some use statements"},{"location":"coreconcepts/hello_me/#compile","text":"TODO: The following code block should be collapsable Check your code matches this: #S:SKIP #![feature(proc_macro_hygiene)] #[macro_use] extern crate hdk ; extern crate hdk_proc_macros ; extern crate serde ; #[macro_use] extern crate serde_derive ; extern crate serde_json ; #[macro_use] extern crate holochain_json_derive ; use hdk :: { entry_definition :: ValidatingEntryType , error :: ZomeApiResult , }; use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , }; use hdk :: holochain_json_api :: { json :: JsonString , error :: JsonError , }; use hdk :: holochain_persistence_api :: { cas :: content :: Address }; use hdk_proc_macros :: zome ; #[derive(Serialize, Deserialize, Debug, DefaultJson,Clone)] pub struct Person { name : String , } #[zome] mod hello_zome { #[init] fn init () { Ok (()) } #[validate_agent] pub fn validate_agent ( validation_data : EntryValidationData < AgentId > ) { Ok (()) } #[entry_def] fn person_entry_def () -> ValidatingEntryType { entry ! ( name : \"person\" , description : \"Person to say hello to\" , sharing : Sharing :: Private , validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Person >| { Ok (()) } ) } #[zome_fn( \"hc_public\" )] fn hello_holo () -> ZomeApiResult < String > { Ok ( \"Hello Holo\" . into ()) } } Package the app (in the nix-shell) and check that there's no compile errors: nix-shell ] hc package","title":"Compile"},{"location":"coreconcepts/hello_me/#create-a-person","text":"Now you need a way for you UI to actually create a person entry. Holochain has a concept called hc_public which is a way of telling the runtime make this function available to call from outside this zome. Add the following lines below the previous person_entry_def function. Add a public function that takes a Person and returns a result with an Address : #S:INCLUDE #[zome_fn( \"hc_public\" )] pub fn create_person ( person : Person ) -> ZomeApiResult < Address > { Create an entry from the passed argument: let entry = Entry :: App ( \"person\" . into (), person . into ()); Commit the entry to your local source chain: let address = hdk :: commit_entry ( & entry ) ? ; Return the Ok result with the new person entry's address: Ok ( address ) }","title":"Create a person"},{"location":"coreconcepts/hello_me/#compile_1","text":"TODO: Add collapsable \"your code should look like this section\" Check for compile errors again: nix-shell ] hc package","title":"Compile"},{"location":"coreconcepts/hello_me/#retrieve-person","text":"Lastly you need a way for your UI to get a person entry back from the source chain. Add the following lines below the create_person function. Add a public retrieve_person function that takes an Address and maybe returns an Entry (because it might not exist): #[zome_fn( \"hc_public\" )] fn retrieve_person ( address : Address ) -> ZomeApiResult < Option < Entry >> { Get the entry from your local storage, asking for it by address: hdk :: get_entry ( & address ) } In Rust the last line is always returned. You do not need to explicitly say return .","title":"Retrieve person"},{"location":"coreconcepts/hello_me/#test","text":"TODO: Add collapsable \"your code should look like this section\" Instead of directly compiling, you can run the test you wrote at the start (the test always compiles before it runs): nix-shell ] hc test If everything went smoothly you will see: 1 ..5 # tests 5 # pass 5 # ok","title":"Test"},{"location":"coreconcepts/hello_me/#ui","text":"Now you can move onto the modifying the UI to interact with zome functions you just created. First let's do some housekeeping and move the JavaScript from the previous tutorial into its own file. Go to the GUI project folder that you created in the Hello GUI tutorial: cd holochain/coreconcepts/gui Create a new hello.js file, open it in your favorite editor, and open the index.html alongside it. Move the everything inside the <script> tag into the hello.js : < script type = \"text/javascript\" > <!-- Everything from HERE to --> // Connection state var holochain_connection = holochainclient . connect ({ url : \"ws://localhost:3401\" }); function hello () { holochain_connection . then (({ callZome , close }) => { callZome ( 'test-instance' , 'hello' , 'hello_holo' )({ \"args\" : {} }). then (( result ) => update_span ( result )) }) } function update_span ( result ) { var span = document . getElementById ( 'output' ); var output = JSON . parse ( result ); span . textContent = \" \" + output . Ok ; } <!-- HERE --> < /script> Add the src attribute to the <script> tag: < script type = \"text/javascript\" src = \"hello.js\" ></ script >","title":"UI"},{"location":"coreconcepts/hello_me/#create-person-ui-widget","text":"Let's start with the HTML elements to create a person. Look for the previous 'say hello' elements. < button onclick = \"hello()\" type = \"button\" > Say Hello </ button > < span > Response: </ span >< span id = \"output\" ></ span > <!-- Put the following lines here --> Below them, add a text box so the user can enter their name: < input type = \"text\" id = \"name\" placeholder = \"Enter your name :)\" >< br > Add a button that calls a (yet to be written) JavaScript function called create_person : < button onclick = \"create_person()\" type = \"button\" > Submit Name </ button > Add a span with the id address_output so you can render the result of this call: < div > Address: < span id = \"address_output\" ></ span ></ div > TODO: Add collapsable html code panel.","title":"Create person UI widget"},{"location":"coreconcepts/hello_me/#switch-to-your-hellojs-file","text":"Let's write the create_person function that will call your zome. Add the create_person function: function create_person () { Get the text box by its ID name and save the current text value into the name variable: var name = document . getElementById ( 'name' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call create_person in your hello zome and pass in the name variable as part of a person structure, then write the result to the console: callZome ( 'test-instance' , 'hello' , 'create_person' )({ person : { name : name } }). then (( result ) => console . log ( result , 'address_output' )) }) }","title":"Switch to your hello.js file"},{"location":"coreconcepts/hello_me/#run-the-server-and-open-a-browser","text":"TODO: Add collapsable hello.js code panel. Go ahead and test your first call. Open a new terminal window and enter the nix-shell: nix-shell https://holochain.love Run the server: nix-shell ] python -m SimpleHTTPServer In your other terminal window package and run your zome: nix-shell ] hc package nix-shell ] hc run -p 8080 Now that both your UI server and your Holochain conductor server are running, open up a browser and go to 0.0.0.0:8000 . You should see the HTML elements you created: Open the developer console, enter your name, and press the \"Submit Name\" button. You should something similar to this: The address you see will probably be different, because you probably typed in your own name.","title":"Run the server and open a browser"},{"location":"coreconcepts/hello_me/#show-the-new-entrys-address","text":"First, a bit of refactoring. If you make the update_span function more generic, then you can reuse it for each element. Pass in the element's ID so that the function can be reused:","title":"Show the new entry's address"},{"location":"coreconcepts/hello_me/#enter-the-browser","text":"Go back to your browser and refresh the page. This time when you enter your name and press Submit Name you will see the address show up:","title":"Enter the browser"},{"location":"coreconcepts/hello_me/#retrieve-a-person-entry-and-show-it-in-the-ui","text":"Back in the index.html file now. Add a text box so the user can enter the address that is returned from the create_person function: < input type = \"text\" id = \"address_in\" placeholder = \"Enter the entry address\" >< br > Add a button that calls the (yet to be written) retrieve_person JavaScript function: < button onclick = \"retrieve_person()\" type = \"button\" > Get Entry </ button > Add a span with the ID entry_output to display the person that is returned from the retrieve_person function: < div > Person: < span id = \"entry_output\" ></ span ></ div >","title":"Retrieve a person entry and show it in the UI"},{"location":"coreconcepts/hello_me/#go-to-your-hellojs-file","text":"Add the retrieve_person function to call the zome function: function retrieve_person () { Get the value from the address_in text box: var address = document . getElementById ( 'address_in' ). value ; Wait for the connection and then make a zome call: holochain_connection . then (({ callZome , close }) => { Call the retrieve_person public zome function and pass in the address then pass the result to update_person : callZome ( 'test-instance' , 'hello' , 'retrieve_person' )({ address : address }). then (( result ) => update_person ( result )) }) } Add the update_person function. It is very similar to update_element except that you need to parse the result and then parse the inner array. function update_person ( result ) { var person = document . getElementById ( 'entry_output' ); var output = JSON . parse ( result ); var output = JSON . parse ( output . Ok . App [ 1 ]); person . textContent = \" \" + output . name ; } #S:HIDE }","title":"Go to your hello.js file"},{"location":"coreconcepts/hello_test/","text":"Hello Test Tutorial \u00b6 Welcome to the hello test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous hello holo tutorial. So make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used. Understand the tests \u00b6 When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in javascript and use the Holochain testing framework Diorama . Open up the hello_holo/test/index.js in your favourite text editor. Have a look through the code and remove the unneeded section. Imports required to do testing. const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) this will print unhandledRejection err if something is not defined. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled dna. const dnaPath = path . join ( __dirname , \"../dist/hello_holo.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'hello_holo' ) Setup the testing environment. This creates two nodes: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that holochain generated based on the my_entry struct. It won't work for our hello holo tutorial so let's remove it. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run () Create a test scenario \u00b6 Tests are organized by creating scenarios. Think of them as a series of actions the user takes when interacting with your app. For this test you simply want to create the Alice user and get her to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is ok: t . ok ( result . Ok ); Check that the result matches what you expected: t . deepEqual ( result , { Ok : 'Hello Holo' }) }) Run the test \u00b6 Now in the hello_helo directory of run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output but if everything went ok then right at the end you will see: # tests 2 # pass 2 # ok Congratulations you have tested your first Holochain app. Look at you go :sparkles:","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_test/#hello-test-tutorial","text":"Welcome to the hello test tutorial. Today you will be learning how to test your Holochain apps. This tutorial will add to the previous hello holo tutorial. So make sure you do that one first. Testing is a really important part of building higher quality apps but it's also a an excellent way to think through how your app will be used.","title":"Hello Test Tutorial"},{"location":"coreconcepts/hello_test/#understand-the-tests","text":"When you ran hc init in the previous tutorial Holochain already generated some tests for you. The tests are written in javascript and use the Holochain testing framework Diorama . Open up the hello_holo/test/index.js in your favourite text editor. Have a look through the code and remove the unneeded section. Imports required to do testing. const path = require ( 'path' ) const tape = require ( 'tape' ) const { Diorama , tapeExecutor , backwardCompatibilityMiddleware } = require ( '@holochain/diorama' ) this will print unhandledRejection err if something is not defined. process . on ( 'unhandledRejection' , error => { console . error ( 'got unhandledRejection:' , error ); }); The path to your compiled dna. const dnaPath = path . join ( __dirname , \"../dist/hello_holo.dna.json\" ) const dna = Diorama . dna ( dnaPath , 'hello_holo' ) Setup the testing environment. This creates two nodes: Alice and Bob. const diorama = new Diorama ({ instances : { alice : dna , bob : dna , }, bridges : [], debugLog : false , executor : tapeExecutor ( require ( 'tape' )), middleware : backwardCompatibilityMiddleware , }) This is the test that holochain generated based on the my_entry struct. It won't work for our hello holo tutorial so let's remove it. Remove the following section: diorama . registerScenario ( \"description of example test\" , async ( s , t , { alice }) => { // Make a call to a Zome function // indicating the function, and passing it an input const addr = await alice . call ( \"my_zome\" , \"create_my_entry\" , { \"entry\" : { \"content\" : \"sample content\" }}) const result = await alice . call ( \"my_zome\" , \"get_my_entry\" , { \"address\" : addr . Ok }) // check for equality of the actual and expected results t . deepEqual ( result , { Ok : { App : [ 'my_entry' , '{\"content\":\"sample content\"}' ] } }) }) This line will run the tests that you have set up. diorama . run ()","title":"Understand the tests"},{"location":"coreconcepts/hello_test/#create-a-test-scenario","text":"Tests are organized by creating scenarios. Think of them as a series of actions the user takes when interacting with your app. For this test you simply want to create the Alice user and get her to call the hello_holo zome function. Then check that you get the result Hello Holo . Place the following just above diorama.run() . Register a test scenario that checks hello_holo() returns the correct value: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { Make a call to the hello_holo Zome function passing no arguments: const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); Make sure the result is ok: t . ok ( result . Ok ); Check that the result matches what you expected: t . deepEqual ( result , { Ok : 'Hello Holo' }) })","title":"Create a test scenario"},{"location":"coreconcepts/hello_test/#run-the-test","text":"Now in the hello_helo directory of run the test like this: $ hc test This will compile and run the test scenario you just wrote. You will see a lot of output but if everything went ok then right at the end you will see: # tests 2 # pass 2 # ok Congratulations you have tested your first Holochain app. Look at you go :sparkles:","title":"Run the test"},{"location":"coreconcepts/hello_world/","text":"Hello World \u00b6 The goal of this tutorial is to add an entry in Alice's instance and then retrieve that same entry in Bob's instance. Make your entry public \u00b6 So far the only entry you have had has been private. But this isn't that useful if you want your users to be able to share entries on the same network. Open up your zomes/hello/code/src/lib.rs file. Change the entry sharing to Sharing::Public : Add bob to the test \u00b6 Before you made a test where Alice made a few zome calls and verified the results. Now to test that the entries can be shared between agents on the same DNA you can use Bob in your tests to interact with Alice. Open up your test/index.js file and add / update the following lines: Add bob to the Scenario: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice , bob }) => { Make the retrieve_person call with the result from create_person : const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that the result was Ok: t . ok ( bob_retrieve_result . Ok ); Check that the result does indeed match the person entry that Alice created: t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Your test should look like this: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice , bob }) => { const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); t . ok ( result . Ok ); t . deepEqual ( result , { Ok : 'Hello Holo' }) const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( bob_retrieve_result . Ok ); t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) }) Run the test \u00b6 Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Now run the test and make sure it passes: nix-shell ] hc test 1..7 # tests 7 # pass 7 # ok Conductor \u00b6 Now it would be cool to see this happen for real outside of a test. Up till now you have only used hc run to run a single instance of a node. However, in order to have two separate instances communicate we need to run holochain directly and pass it a config file. Before you can create the config file, you will need to generate some keys for your agents. Use keygen in your nix-shell to generate a key for each agent: nix-shell] hc keygen -n This will output something similar to the following: Generating keystore (this will take a few moments)... Succesfully created new agent keystore. Public address: HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz Keystore written to: /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz You can set this file in a conductor config as keystore_file for an agent. Take note of the Public address , you will need it later. cp /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz agent1.key Now do this again but cp it to agent2.key: cp /Users/..... agent2.key Config file \u00b6 Create a new file in the root directory of your project called conductor-config.toml . Add an agent with id test_agent1 and name Agent 1 : # ----------- Agents ----------- [[agents]] id = \"test_agent1\" name = \"Agent 1\" Use the public address from hc keygen that you made for agent 1 before here: public_address = \"HcScJtQkeJ4hkdqtxrdgh8jPybRynkaxmCSFZxKG6Nsf3tei6zRAnEdy97Qzeua\" keystore_file = \"./agent1.key\" Add an agent with id test_agent2 and name Agent 2 : [[agents]] id = \"test_agent2\" name = \"Agent 2\" Use the public address from hc keygen that you made for agent 2 before here: public_address = \"HcSCinAe4uWs66r7pxnBn9xNcCJ5kivg5MqhvZ7rbmqbfzeg8e4Aun8ziwiersz\" keystore_file = \"./agent2.key\" Run package and get your dna's hash: nix-shell] hc package You will see something similar to this: DNA hash: QmS7wUJj6XZR1SBVk1idGh6bK8gN6RNSFXP2GoC8yCJUzn Add the dna with id hello and use the DNA hash you just made above: # ----------- DNAs ----------- [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"QmZcje6BoEURaX1vCrsDY11v7fHMd6spmVpzkQ1Vxp9n6D\" Add the Alice instance with the hello dna: [[instances]] id = \"Alice\" dna = \"hello\" agent = \"test_agent1\" [instances.storage] type = \"memory\" Add the Bob instance with the same hello dna: [[instances]] id = \"Bob\" dna = \"hello\" agent = \"test_agent2\" [instances.storage] type = \"memory\" Setup the websocket connection on socket 3041 : [[interfaces]] id = \"websocket_interface\" [interfaces.driver] type = \"websocket\" port = 3401 Add your instances to this interface: [[interfaces.instances]] id = \"Alice\" [[interfaces.instances]] id = \"Bob\" Allow the users to choose their agent \u00b6 Before you can use two agents you need a way for the UI to specify which agent the user wants to use. You can do this by setting the instance id in the zome call. You can think of an instance as a running version of a DNA. Like a variable is an instance of a struct. Open the gui/index.html . Add a text box for your users to set the agent id: < input type = \"text\" id = \"instance\" placeholder = \"Enter your instance id\" >< br > Open the gui/index.js and do the following for every callZome call: Run the app and two UIs \u00b6 Now the fun part where you get to play with what you just wrote. Open up a three terminal windows and enter the nix-shell in each one: nix-shell https://holochain.love Terminal one \u00b6 Go to the root folder of your app: nix-shell] cd /path/to/my/app Start by running the conductor. It's a bit different this time, instead of hc run you will use holochain directly: nix-shell] holochain -c conductor-config.toml Terminal two \u00b6 Go to the root folder of your gui: nix-shell] cd /path/to/my/gui Run a gui on port 8000 : nix-shell] python -m SimpleHTTPServer 8000 Terminal there \u00b6 Go to the root folder of your gui: nix-shell] cd /path/to/my/gui Run a gui on port 8001 : nix-shell] python -m SimpleHTTPServer 8001 Open up the browser \u00b6 Open two tabs. Tab one \u00b6 Go to 0.0.0.0:8000 . Enter Alice into the Enter your instance id text box. Tab two \u00b6 Go to 0.0.0.0:8001 . Enter Bob into the Enter your instance id text box. Tab one - Alice \u00b6 Create a person with your name: Tab two - Bob \u00b6 Copy the address from the Alice tab and retrieve the person entry:","title":"Hello World"},{"location":"coreconcepts/hello_world/#hello-world","text":"The goal of this tutorial is to add an entry in Alice's instance and then retrieve that same entry in Bob's instance.","title":"Hello World"},{"location":"coreconcepts/hello_world/#make-your-entry-public","text":"So far the only entry you have had has been private. But this isn't that useful if you want your users to be able to share entries on the same network. Open up your zomes/hello/code/src/lib.rs file. Change the entry sharing to Sharing::Public :","title":"Make your entry public"},{"location":"coreconcepts/hello_world/#add-bob-to-the-test","text":"Before you made a test where Alice made a few zome calls and verified the results. Now to test that the entries can be shared between agents on the same DNA you can use Bob in your tests to interact with Alice. Open up your test/index.js file and add / update the following lines: Add bob to the Scenario: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice }) => { diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice , bob }) => { Make the retrieve_person call with the result from create_person : const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); Check that the result was Ok: t . ok ( bob_retrieve_result . Ok ); Check that the result does indeed match the person entry that Alice created: t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) Your test should look like this: diorama . registerScenario ( \"Test hello holo\" , async ( s , t , { alice , bob }) => { const result = await alice . call ( \"hello\" , \"hello_holo\" , {}); t . ok ( result . Ok ); t . deepEqual ( result , { Ok : 'Hello Holo' }) const create_result = await alice . call ( \"hello\" , \"create_person\" , { \"person\" : { \"name\" : \"Alice\" }}); t . ok ( create_result . Ok ); const retrieve_result = await alice . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( retrieve_result . Ok ); t . deepEqual ( retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) const bob_retrieve_result = await bob . call ( \"hello\" , \"retrieve_person\" , { \"address\" : create_result . Ok }); t . ok ( bob_retrieve_result . Ok ); t . deepEqual ( bob_retrieve_result , { Ok : { App : [ 'person' , '{\"name\":\"Alice\"}' ] }}) })","title":"Add bob to the test"},{"location":"coreconcepts/hello_world/#run-the-test","text":"Enter the nix-shell if you don't have it open already: nix-shell https://holochain.love Now run the test and make sure it passes: nix-shell ] hc test 1..7 # tests 7 # pass 7 # ok","title":"Run the test"},{"location":"coreconcepts/hello_world/#conductor","text":"Now it would be cool to see this happen for real outside of a test. Up till now you have only used hc run to run a single instance of a node. However, in order to have two separate instances communicate we need to run holochain directly and pass it a config file. Before you can create the config file, you will need to generate some keys for your agents. Use keygen in your nix-shell to generate a key for each agent: nix-shell] hc keygen -n This will output something similar to the following: Generating keystore (this will take a few moments)... Succesfully created new agent keystore. Public address: HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz Keystore written to: /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz You can set this file in a conductor config as keystore_file for an agent. Take note of the Public address , you will need it later. cp /Users/user/Library/Preferences/org.holochain.holochain/keys/HcSCJhRioEqzvx9sooOfw6ANditrqdcxwfV7p7KP6extmnmzJIs83uKmfO9b8kz agent1.key Now do this again but cp it to agent2.key: cp /Users/..... agent2.key","title":"Conductor"},{"location":"coreconcepts/hello_world/#config-file","text":"Create a new file in the root directory of your project called conductor-config.toml . Add an agent with id test_agent1 and name Agent 1 : # ----------- Agents ----------- [[agents]] id = \"test_agent1\" name = \"Agent 1\" Use the public address from hc keygen that you made for agent 1 before here: public_address = \"HcScJtQkeJ4hkdqtxrdgh8jPybRynkaxmCSFZxKG6Nsf3tei6zRAnEdy97Qzeua\" keystore_file = \"./agent1.key\" Add an agent with id test_agent2 and name Agent 2 : [[agents]] id = \"test_agent2\" name = \"Agent 2\" Use the public address from hc keygen that you made for agent 2 before here: public_address = \"HcSCinAe4uWs66r7pxnBn9xNcCJ5kivg5MqhvZ7rbmqbfzeg8e4Aun8ziwiersz\" keystore_file = \"./agent2.key\" Run package and get your dna's hash: nix-shell] hc package You will see something similar to this: DNA hash: QmS7wUJj6XZR1SBVk1idGh6bK8gN6RNSFXP2GoC8yCJUzn Add the dna with id hello and use the DNA hash you just made above: # ----------- DNAs ----------- [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"QmZcje6BoEURaX1vCrsDY11v7fHMd6spmVpzkQ1Vxp9n6D\" Add the Alice instance with the hello dna: [[instances]] id = \"Alice\" dna = \"hello\" agent = \"test_agent1\" [instances.storage] type = \"memory\" Add the Bob instance with the same hello dna: [[instances]] id = \"Bob\" dna = \"hello\" agent = \"test_agent2\" [instances.storage] type = \"memory\" Setup the websocket connection on socket 3041 : [[interfaces]] id = \"websocket_interface\" [interfaces.driver] type = \"websocket\" port = 3401 Add your instances to this interface: [[interfaces.instances]] id = \"Alice\" [[interfaces.instances]] id = \"Bob\"","title":"Config file"},{"location":"coreconcepts/hello_world/#allow-the-users-to-choose-their-agent","text":"Before you can use two agents you need a way for the UI to specify which agent the user wants to use. You can do this by setting the instance id in the zome call. You can think of an instance as a running version of a DNA. Like a variable is an instance of a struct. Open the gui/index.html . Add a text box for your users to set the agent id: < input type = \"text\" id = \"instance\" placeholder = \"Enter your instance id\" >< br > Open the gui/index.js and do the following for every callZome call:","title":"Allow the users to choose their agent"},{"location":"coreconcepts/hello_world/#run-the-app-and-two-uis","text":"Now the fun part where you get to play with what you just wrote. Open up a three terminal windows and enter the nix-shell in each one: nix-shell https://holochain.love","title":"Run the app and two UIs"},{"location":"coreconcepts/hello_world/#terminal-one","text":"Go to the root folder of your app: nix-shell] cd /path/to/my/app Start by running the conductor. It's a bit different this time, instead of hc run you will use holochain directly: nix-shell] holochain -c conductor-config.toml","title":"Terminal one"},{"location":"coreconcepts/hello_world/#terminal-two","text":"Go to the root folder of your gui: nix-shell] cd /path/to/my/gui Run a gui on port 8000 : nix-shell] python -m SimpleHTTPServer 8000","title":"Terminal two"},{"location":"coreconcepts/hello_world/#terminal-there","text":"Go to the root folder of your gui: nix-shell] cd /path/to/my/gui Run a gui on port 8001 : nix-shell] python -m SimpleHTTPServer 8001","title":"Terminal there"},{"location":"coreconcepts/hello_world/#open-up-the-browser","text":"Open two tabs.","title":"Open up the browser"},{"location":"coreconcepts/hello_world/#tab-one","text":"Go to 0.0.0.0:8000 . Enter Alice into the Enter your instance id text box.","title":"Tab one"},{"location":"coreconcepts/hello_world/#tab-two","text":"Go to 0.0.0.0:8001 . Enter Bob into the Enter your instance id text box.","title":"Tab two"},{"location":"coreconcepts/hello_world/#tab-one-alice","text":"Create a person with your name:","title":"Tab one - Alice"},{"location":"coreconcepts/hello_world/#tab-two-bob","text":"Copy the address from the Alice tab and retrieve the person entry:","title":"Tab two - Bob"},{"location":"coreconcepts/simple_micro_blog/","text":"Simple Micro Blog tutorial \u00b6 Welcome to the Simple Micro blog tutorial in the Core Concepts tutorial series. The aim of this tutorial is to show how entries can be linked to each other in a Holochain app. A link is simply a relationship between two entries. It's a useful way to find some data from something you already know. For example, you could link from your user's agent ID entry to their blog posts. You will be building on the previous Hello World tutorial and making a super simple blog app. The app's users will be able to post a blog post and then retrieve other users' posts. DNA hash \u00b6 The way you run your conductor has changed from hc run to calling holochain directly. As a consequence, the hash of your app's DNA now lives in the conductor-config.toml file. However, anytime you change your code and run hc package the hash will be different. So you will need to update the conductor-config.toml file. Enter the nix-shell: nix-shell https://holochain.love Package your app: hc package Copy the DNA hash (example shown): DNA hash: QmfKyAk2jXgESca2zju6QbkLqUM1xEjqDsmHRgRxoFp39q Update the conductor-config.toml dna hash: [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<new_dna_hash>\" Post \u00b6 We will store our posts as a Post struct that holds a message of type String , a timestamp of type u64 , and an author ID of type Address . We're done with the Hello World tutorial, so remove the Person struct and add the Post struct: Entry \u00b6 Update the person entry type definition to post : Agent ID \u00b6 Now you have a post entry but you also need some way to find the posts an agent makes. To do this you can create an agent 'anchor' entry which you will use to link to the posts that the user makes. An anchor is a simple string whose only purpose is to be an easy-to-find entry to attach links to. Define an agent anchor entry type by adding the following lines below the post_entry_def . Add an agent_entry_def function which creates an entry type for the agent: #[entry_def] fn agent_entry_def () -> ValidatingEntryType { Start the entry! macro for the agent entry: entry ! ( name : \"agent\" , description : \"Hash of agent\" , Set sharing to public so other agents can find this agent's anchor (and hence their posts): sharing : Sharing :: Public , Add basic validation to make sure this is the Agent type that is passed in: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Agent >| { Ok (()) }, Now you want to be able to link this agent entry to the post entry. Start out with the to! link macro, which lets you create link definitions that link from this entry type to another entry type: links : [ to ! ( Define a link type from this entry to the post entry called author_post : \"post\" , link_type : \"author_post\" , Add empty validation for this link: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: LinkValidationData | { Ok (()) } ) ] ) } Create a post \u00b6 Remove the create_person function. You need a function for creating a new post. Think about the ingredients that might go into the Post structure: a message, a timestamp, and and the author's ID. The message will come from the UI. For simplicity the timestamp will come from the UI as well. Time is a pretty tricky concept in the distributed world and requires careful planning. The author's ID will come from the special constant hdk::AGENT_ADDRESS , which you can access from your zome functions. Why do I have to specify a timestamp and author? Aren't they already in the entry's header? \u00b6 If two agents publish entries with identical type and content, they'll have the same hash on the DHT. That means that, for all purposes, there's only one entry with two authors. This is fine for some cases. But it causes problems in a microblog. When one author wants to delete an existing message, does the other author's copy get deleted too? Adding a timestamp and author ID makes the two posts distinct, with their own hashes. Add a public create_post function that takes a message as a String and a timestamp as a u64 : #[zome_fn( \"hc_public\" )] pub fn create_post ( message : String , timestamp : u64 ) -> ZomeApiResult < Address > { Create the Post using the message, timestamp and this agents address: let post = Post { message , timestamp , author_id : hdk :: AGENT_ADDRESS . clone (), }; Create the Agent struct from the AGENT_ADDRESS , turn it into an Entry and commit it: let agent_id = Agent { id : hdk :: AGENT_ADDRESS . clone (). into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: commit_entry ( & entry ) ? ; Commit the post entry: let entry = Entry :: App ( \"post\" . into (), post . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Create an author_post link from the agent to the post: hdk :: link_entries ( & agent_address , & address , \"author_post\" , \"\" ) ? ; Return everything is Ok with the new post's address: Ok ( address ) } Retrieve all of a user's posts \u00b6 Add the retrieve_posts public function that takes an author address and returns a vector of posts: #[zome_fn( \"hc_public\" )] fn retrieve_posts ( author_address : Address ) -> ZomeApiResult < Vec < Post >> { Create an Agent struct from the passed address, turn it into an Entry , and calculate its address: let agent_id = Agent { id : author_address . into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: entry_address ( & entry ) ? ; Get all the author_post links from the agent's address and load them as the Post type: hdk :: utils :: get_links_and_load_type ( & address , LinkMatch :: Exactly ( \"author_post\" ), LinkMatch :: Any , ) } (Note that because you've already told Rust that this function is going to return a vector of posts, the compiler will tell get_links_and_load_type what type to use in the conversion.) We're using a new directive, link::LinkMatch . You'll need to add it to your use statements at the top of the file: use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , link :: LinkMatch , }; Get the agent's ID \u00b6 As a user, you will need some way of getting your own agent's ID in the UI later so that you can pass it to others. Then they can try getting your posts. Add a public get_agent_id function that returns an Address : #[zome_fn( \"hc_public\" )] fn get_agent_id () -> ZomeApiResult < Address > { For this app you can use the agent's address as their ID, because that's what we're storing in the agent anchor entries: Ok ( hdk :: AGENT_ADDRESS . clone ()) } Show the agent's ID in the UI \u00b6 Let's start on the UI. Go to your GUI folder and open up the index.html file. To make it easy to pass around agent ID, you can display the ID for the instance that each GUI is currently targeting. This should happen when the page loads and when the instance ID changes. Add an onload event to the body that will call the get_agent_id function when the page loads: < body onload = \"get_agent_id()\" > Add an onfocusout event to the instance text box that will call the same function when unfocused: < input type = \"text\" id = \"instance\" onfocusout = \"get_agent_id()\" placeholder = \"Enter your instance ID\" > Now open up the hello.js file and add the get_agent_id function: function get_agent_id () { Get the instance value and set up a zome call connection: var instance = document . getElementById ( 'instance' ). value ; holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { Call the get_agent_id zome function and then update the agent_id element with the result: callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) } Update the UI to allow posts to be created \u00b6 Back in index.html turn the \"create person\" HTML into a post entry widget. Use a textarea , call the create_post function, and update all the labels and IDs: Update the UI to retrieve an agent's posts \u00b6 Update the \"retrieve person\" HTML to retrieve posts: Call create_post from JavaScript \u00b6 In the hello.js file add the create_post function that your HTML calls: function create_post () { Get the post message and instance ID: var message = document . getElementById ( 'post' ). value ; var instance = document . getElementById ( 'instance' ). value ; Get the current timestamp: var timestamp = Date . now (); Make a zome call to create_post with the message and timestamp: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'create_post' )({ message : message , timestamp : timestamp }). then (( result ) => update_element ( result , 'post_address' )) }) } Update the posts list dynamically \u00b6 Add an empty list below the post_agent_id text box: < ul id = \"posts_output\" ></ ul > In the hello.js file add the following lines to update the posts_output dynamically. Add the display_posts function: function display_posts ( result ) { Get the posts_output HTML element: var list = document . getElementById ( 'posts_output' ); Wipe the current contents of the list, if any: list . innerHTML = \"\" ; Parse the zome function's result as JSON: var output = JSON . parse ( result ); Sort the posts by their timestamps: var posts = output . Ok . sort (( a , b ) => a . timestamp - b . timestamp ); For each post add a <li> element that contains the post's message: for ( post of posts ) { var node = document . createElement ( \"LI\" ); var textnode = document . createTextNode ( post . message ); node . appendChild ( textnode ); list . appendChild ( node ); } } Get this agent's ID \u00b6 Add the get_agent_id function: function get_agent_id () { var instance = document . getElementById ( 'instance' ). value ; Call the get_agent_id function and update the agent_id element: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) } Retrieve an agent's posts \u00b6 This is very similar to retrieve_person , so just update that function:","title":"Simple Micro Blog tutorial"},{"location":"coreconcepts/simple_micro_blog/#simple-micro-blog-tutorial","text":"Welcome to the Simple Micro blog tutorial in the Core Concepts tutorial series. The aim of this tutorial is to show how entries can be linked to each other in a Holochain app. A link is simply a relationship between two entries. It's a useful way to find some data from something you already know. For example, you could link from your user's agent ID entry to their blog posts. You will be building on the previous Hello World tutorial and making a super simple blog app. The app's users will be able to post a blog post and then retrieve other users' posts.","title":"Simple Micro Blog tutorial"},{"location":"coreconcepts/simple_micro_blog/#dna-hash","text":"The way you run your conductor has changed from hc run to calling holochain directly. As a consequence, the hash of your app's DNA now lives in the conductor-config.toml file. However, anytime you change your code and run hc package the hash will be different. So you will need to update the conductor-config.toml file. Enter the nix-shell: nix-shell https://holochain.love Package your app: hc package Copy the DNA hash (example shown): DNA hash: QmfKyAk2jXgESca2zju6QbkLqUM1xEjqDsmHRgRxoFp39q Update the conductor-config.toml dna hash: [[dnas]] id = \"hello\" file = \"dist/hello_holo.dna.json\" hash = \"<new_dna_hash>\"","title":"DNA hash"},{"location":"coreconcepts/simple_micro_blog/#post","text":"We will store our posts as a Post struct that holds a message of type String , a timestamp of type u64 , and an author ID of type Address . We're done with the Hello World tutorial, so remove the Person struct and add the Post struct:","title":"Post"},{"location":"coreconcepts/simple_micro_blog/#entry","text":"Update the person entry type definition to post :","title":"Entry"},{"location":"coreconcepts/simple_micro_blog/#agent-id","text":"Now you have a post entry but you also need some way to find the posts an agent makes. To do this you can create an agent 'anchor' entry which you will use to link to the posts that the user makes. An anchor is a simple string whose only purpose is to be an easy-to-find entry to attach links to. Define an agent anchor entry type by adding the following lines below the post_entry_def . Add an agent_entry_def function which creates an entry type for the agent: #[entry_def] fn agent_entry_def () -> ValidatingEntryType { Start the entry! macro for the agent entry: entry ! ( name : \"agent\" , description : \"Hash of agent\" , Set sharing to public so other agents can find this agent's anchor (and hence their posts): sharing : Sharing :: Public , Add basic validation to make sure this is the Agent type that is passed in: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: EntryValidationData < Agent >| { Ok (()) }, Now you want to be able to link this agent entry to the post entry. Start out with the to! link macro, which lets you create link definitions that link from this entry type to another entry type: links : [ to ! ( Define a link type from this entry to the post entry called author_post : \"post\" , link_type : \"author_post\" , Add empty validation for this link: validation_package : || { hdk :: ValidationPackageDefinition :: Entry }, validation : | _validation_data : hdk :: LinkValidationData | { Ok (()) } ) ] ) }","title":"Agent ID"},{"location":"coreconcepts/simple_micro_blog/#create-a-post","text":"Remove the create_person function. You need a function for creating a new post. Think about the ingredients that might go into the Post structure: a message, a timestamp, and and the author's ID. The message will come from the UI. For simplicity the timestamp will come from the UI as well. Time is a pretty tricky concept in the distributed world and requires careful planning. The author's ID will come from the special constant hdk::AGENT_ADDRESS , which you can access from your zome functions.","title":"Create a post"},{"location":"coreconcepts/simple_micro_blog/#why-do-i-have-to-specify-a-timestamp-and-author-arent-they-already-in-the-entrys-header","text":"If two agents publish entries with identical type and content, they'll have the same hash on the DHT. That means that, for all purposes, there's only one entry with two authors. This is fine for some cases. But it causes problems in a microblog. When one author wants to delete an existing message, does the other author's copy get deleted too? Adding a timestamp and author ID makes the two posts distinct, with their own hashes. Add a public create_post function that takes a message as a String and a timestamp as a u64 : #[zome_fn( \"hc_public\" )] pub fn create_post ( message : String , timestamp : u64 ) -> ZomeApiResult < Address > { Create the Post using the message, timestamp and this agents address: let post = Post { message , timestamp , author_id : hdk :: AGENT_ADDRESS . clone (), }; Create the Agent struct from the AGENT_ADDRESS , turn it into an Entry and commit it: let agent_id = Agent { id : hdk :: AGENT_ADDRESS . clone (). into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: commit_entry ( & entry ) ? ; Commit the post entry: let entry = Entry :: App ( \"post\" . into (), post . into ()); let address = hdk :: commit_entry ( & entry ) ? ; Create an author_post link from the agent to the post: hdk :: link_entries ( & agent_address , & address , \"author_post\" , \"\" ) ? ; Return everything is Ok with the new post's address: Ok ( address ) }","title":"Why do I have to specify a timestamp and author? Aren't they already in the entry's header?"},{"location":"coreconcepts/simple_micro_blog/#retrieve-all-of-a-users-posts","text":"Add the retrieve_posts public function that takes an author address and returns a vector of posts: #[zome_fn( \"hc_public\" )] fn retrieve_posts ( author_address : Address ) -> ZomeApiResult < Vec < Post >> { Create an Agent struct from the passed address, turn it into an Entry , and calculate its address: let agent_id = Agent { id : author_address . into () }; let entry = Entry :: App ( \"agent\" . into (), agent_id . into ()); let agent_address = hdk :: entry_address ( & entry ) ? ; Get all the author_post links from the agent's address and load them as the Post type: hdk :: utils :: get_links_and_load_type ( & address , LinkMatch :: Exactly ( \"author_post\" ), LinkMatch :: Any , ) } (Note that because you've already told Rust that this function is going to return a vector of posts, the compiler will tell get_links_and_load_type what type to use in the conversion.) We're using a new directive, link::LinkMatch . You'll need to add it to your use statements at the top of the file: use hdk :: holochain_core_types :: { entry :: Entry , dna :: entry_types :: Sharing , link :: LinkMatch , };","title":"Retrieve all of a user's posts"},{"location":"coreconcepts/simple_micro_blog/#get-the-agents-id","text":"As a user, you will need some way of getting your own agent's ID in the UI later so that you can pass it to others. Then they can try getting your posts. Add a public get_agent_id function that returns an Address : #[zome_fn( \"hc_public\" )] fn get_agent_id () -> ZomeApiResult < Address > { For this app you can use the agent's address as their ID, because that's what we're storing in the agent anchor entries: Ok ( hdk :: AGENT_ADDRESS . clone ()) }","title":"Get the agent's ID"},{"location":"coreconcepts/simple_micro_blog/#show-the-agents-id-in-the-ui","text":"Let's start on the UI. Go to your GUI folder and open up the index.html file. To make it easy to pass around agent ID, you can display the ID for the instance that each GUI is currently targeting. This should happen when the page loads and when the instance ID changes. Add an onload event to the body that will call the get_agent_id function when the page loads: < body onload = \"get_agent_id()\" > Add an onfocusout event to the instance text box that will call the same function when unfocused: < input type = \"text\" id = \"instance\" onfocusout = \"get_agent_id()\" placeholder = \"Enter your instance ID\" > Now open up the hello.js file and add the get_agent_id function: function get_agent_id () { Get the instance value and set up a zome call connection: var instance = document . getElementById ( 'instance' ). value ; holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { Call the get_agent_id zome function and then update the agent_id element with the result: callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) }","title":"Show the agent's ID in the UI"},{"location":"coreconcepts/simple_micro_blog/#update-the-ui-to-allow-posts-to-be-created","text":"Back in index.html turn the \"create person\" HTML into a post entry widget. Use a textarea , call the create_post function, and update all the labels and IDs:","title":"Update the UI to allow posts to be created"},{"location":"coreconcepts/simple_micro_blog/#update-the-ui-to-retrieve-an-agents-posts","text":"Update the \"retrieve person\" HTML to retrieve posts:","title":"Update the UI to retrieve an agent's posts"},{"location":"coreconcepts/simple_micro_blog/#call-create_post-from-javascript","text":"In the hello.js file add the create_post function that your HTML calls: function create_post () { Get the post message and instance ID: var message = document . getElementById ( 'post' ). value ; var instance = document . getElementById ( 'instance' ). value ; Get the current timestamp: var timestamp = Date . now (); Make a zome call to create_post with the message and timestamp: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'create_post' )({ message : message , timestamp : timestamp }). then (( result ) => update_element ( result , 'post_address' )) }) }","title":"Call create_post from JavaScript"},{"location":"coreconcepts/simple_micro_blog/#update-the-posts-list-dynamically","text":"Add an empty list below the post_agent_id text box: < ul id = \"posts_output\" ></ ul > In the hello.js file add the following lines to update the posts_output dynamically. Add the display_posts function: function display_posts ( result ) { Get the posts_output HTML element: var list = document . getElementById ( 'posts_output' ); Wipe the current contents of the list, if any: list . innerHTML = \"\" ; Parse the zome function's result as JSON: var output = JSON . parse ( result ); Sort the posts by their timestamps: var posts = output . Ok . sort (( a , b ) => a . timestamp - b . timestamp ); For each post add a <li> element that contains the post's message: for ( post of posts ) { var node = document . createElement ( \"LI\" ); var textnode = document . createTextNode ( post . message ); node . appendChild ( textnode ); list . appendChild ( node ); } }","title":"Update the posts list dynamically"},{"location":"coreconcepts/simple_micro_blog/#get-this-agents-id","text":"Add the get_agent_id function: function get_agent_id () { var instance = document . getElementById ( 'instance' ). value ; Call the get_agent_id function and update the agent_id element: holochainclient . connect ({ url : \"ws://localhost:3401\" }). then (({ callZome , close }) => { callZome ( instance , 'hello' , 'get_agent_id' )({}). then (( result ) => update_element ( result , 'agent_id' )) }) }","title":"Get this agent's ID"},{"location":"coreconcepts/simple_micro_blog/#retrieve-an-agents-posts","text":"This is very similar to retrieve_person , so just update that function:","title":"Retrieve an agent's posts"}]}